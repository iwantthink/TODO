# 插件加载机制

[Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)

[ClassLoader原理学习.md](https://github.com/iwantthink/TODO/blob/master/AOP/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.md)

# 1. 简介

通常情况下,插件会以额外的文件 存在于assets目录 或者 从网络下载.**这里就涉及到了一个问题 如何将额外的class文件加载到内存中.例如我们启动一个Activity,之前我们已经解决了启动未在清单文件中声明的Activity,但这时这个Activity存在于插件中,Activity是否能正确加载?**

**本文基于Android27**
# 2. 启动插件中的Activity会遇到的问题

## 2.1 正常Activity类的加载逻辑
Activity类对象的具体创建在`ActivityThread.performLaunchActivity()`方法中:

	ContextImpl appContext = createBaseContextForActivity(r);
	Activity activity = null;
	try {
		java.lang.ClassLoader cl = appContext.getClassLoader();
		activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
		``省略代码``
	} catch (Exception e) {
		``省略代码```
	}
	// Instrumentation.newActivity()
    public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        return (Activity)cl.loadClass(className).newInstance();
    }


- Android通过`ClassLoader`将目标类加载到内存中,然后通过反射调用构造函数将该类创建出来

- Activity创建过程中使用的ClassLoader就是`PathClassLoader`

		//ContextImpl.getClassLoader()
	    @Override
	    public ClassLoader getClassLoader() {
	        return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
	    }
		//ClassLoader
	    @CallerSensitive
	    public static ClassLoader getSystemClassLoader() {
	        return SystemClassLoader.loader;
	    }
		//ClassLoader
	    static private class SystemClassLoader {
	        public static ClassLoader loader = ClassLoader.createSystemClassLoader();
	    }
		//ClassLoader.createSystemClassLoader()
	    private static ClassLoader createSystemClassLoader() {
	        String classPath = System.getProperty("java.class.path", ".");
	        String librarySearchPath = System.getProperty("java.library.path", "");
	        return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
	    }

- **Android系统使用PathClassLoader来加载系统类和应用程序的类，如果是加载应用程序类，则会加载`data/app/`目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载哪种类型的文件，最终都是加载dex文件**

## 2.2 插件遇到的问题

Android系统使用ClassLoader机制去加载类,在Activity类的加载过程之中,使用了`PathClassLoader`类加载器. **这个类加载器有一个特点就是只能加载已安装应用的dex或apk文件**,插件大多不符合这个条件(插件位置是任意的),因此正常情况下系统无法加载插件中的类,也没办法创建插件中的Activity对象

# 3. ClassLoader机制介绍

具体的去看[ClassLoader原理学习.md](https://github.com/iwantthink/TODO/blob/master/AOP/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.md)

>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。


Java类加载过程包括:加载,验证,准备,解析和初始化五个阶段,**加载阶段是最适合修改的地方**.加载阶段主要完成三件事:

1. 根据类的全限定名来获取定义此类的二进制字节流

2. 将这个字节流锁代表的静态存储结构转换为JVM方法区中的运行时数据结构

3. 在内存中生成一个代表这个类的`java.lang.Class`对象,作为方法区这个类的各种数据的访问入口

**Android中的ClassLoader:**

- **Android系统使用`PathClassLoader`来加载系统类和应用程序的类,其有一个限制:只能加载已安装应用的dex或apk文件.**

- **另外还提供了`DexClassLoader`,可以用来加载不能用`PathClassLoader`加载的类**


# 4. 如何加载插件?

## 4.1 解决思路

之前已经提到 插件的类无法被`PathClassLoader`加载,那么解决这个问题有俩个方式:

1. 全面接管系统的类加载过程

2. 将插件位置告诉系统类加载器,让系统帮忙加载

- **这俩种方式都需要干预类加载这个过程**

## 4.2 Activity加载所使用的ClassLoader

1. `ActivityThread.performLaunchActivity()`

		ContextImpl appContext = createBaseContextForActivity(r);
		java.lang.ClassLoader cl = appContext.getClassLoader();

	- 具体的类加载器 是交给`ContextImpl`来实现的

2. `ContextImpl.getClassLoader()`

	    @Override
	    public ClassLoader getClassLoader() {
	        return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
	    }

	- **`mClassLoader`是ClassLoader的缓存.**
	
	- `mPackageInfo`是`LoadedApk`类型,从构造函数中传入(在`ActivityThread.performLaunchActivity().createBaseContextForActivity()`中被创建),可能为空(被`@Nullable`修饰)

	**`LoadedApk`对象是APK文件在内存中的表示.APk文件的相关信息,比如Apk文件的代码和资源,更具体点就是代码里面的Activity,Service等组件的信息**

			//LoadedApk
			Local state maintained about a currently loaded .apk.

- 通过`LoadedApk`获取类加载器:

	    private void createOrUpdateClassLoaderLocked(List<String> addedPaths) {
	        if (mPackageName.equals("android")) {
	            // Note: This branch is taken for system server and we don't need to setup
	            // jit profiling support.
	            if (mClassLoader != null) {
	                // nothing to update
	                return;
	            }
	
	            if (mBaseClassLoader != null) {
	                mClassLoader = mBaseClassLoader;
	            } else {
	                mClassLoader = ClassLoader.getSystemClassLoader();
	            }
	
	            return;
	        }
			``省略代码``
	    }
	
	    public ClassLoader getClassLoader() {
	        synchronized (this) {
	            if (mClassLoader == null) {
	                createOrUpdateClassLoaderLocked(null /*addedPaths*/);
	            }
	            return mClassLoader;
	        }
	    }

- 通过`ClassLoader`获取类加载器:

	    @CallerSensitive
	    public static ClassLoader getSystemClassLoader() {
	        return SystemClassLoader.loader;
	    }

	    static private class SystemClassLoader {
	        public static ClassLoader loader = ClassLoader.createSystemClassLoader();
	    }

	    private static ClassLoader createSystemClassLoader() {
	        String classPath = System.getProperty("java.class.path", ".");
	        String librarySearchPath = System.getProperty("java.library.path", "");
	        return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
	    }

**Activity所用的类加载器获取总结:**

- **ClassLoader优先从缓存中获取,没有缓存则通过`LoadedApk`获取,没有`LoadedApk`则通过`ClassLoader`获取**.**通过`LoadedApk`最终也是通过`ClassLoader`获取类加载器**

## 4.3 Hook点分析

已经知道类加载器的获取 会优先借助`LoadedApk`(`LoadedApk.getClassLoader()`),其次再是直接通过`ClassLoader`获取.

那么查看一下`LoadedApk`的生成方式,查看是否能够借助这个类来实现对`ClassLoader`的修改

### 4.3.1 LoadedApk的创建方式

在`ActivityThread.mH.handleMessage()`的`LAUNCH_ACTIVITY`中查看到 `LoadedApk`的首次创建

		case LAUNCH_ACTIVITY: {
		
			final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
			r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
			handleLaunchActivity(r, null, "LAUNCH_ACTIVITY");
	
		} break;
		
	    public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
	            CompatibilityInfo compatInfo) {
	        return getPackageInfo(ai, compatInfo, null, false, true, false);
	    }

	    private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
	            ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
	            boolean registerPackage) {
			//获取userid,并判断是否是同一个
	        final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));
	        synchronized (mResourcesManager) {
				//根据 userid 获取缓存信息
	            WeakReference<LoadedApk> ref;
	            if (differentUser) {
	                // Caching not supported across users
	                ref = null;
				//includeCode = true
	            } else if (includeCode) {
	                ref = mPackages.get(aInfo.packageName);
	            } else {
	                ref = mResourcePackages.get(aInfo.packageName);
	            }
	
	            LoadedApk packageInfo = ref != null ? ref.get() : null;
	            if (packageInfo == null || (packageInfo.mResources != null
	                    && !packageInfo.mResources.getAssets().isUpToDate())) {
					//缓存不存在,直接创建
	                packageInfo =
	                    new LoadedApk(this, aInfo, compatInfo, baseLoader,
	                            securityViolation, includeCode &&
	                            (aInfo.flags&ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);
					//存入缓存
	                if (mSystemThread && "android".equals(aInfo.packageName)) {
	                    packageInfo.installSystemApplicationInfo(aInfo,
	                            getSystemContext().mPackageInfo.getClassLoader());
	                }
	
	                if (differentUser) {
	                    // Caching not supported across users
	                } else if (includeCode) {
	                    mPackages.put(aInfo.packageName,
	                            new WeakReference<LoadedApk>(packageInfo));
	                } else {
	                    mResourcePackages.put(aInfo.packageName,
	                            new WeakReference<LoadedApk>(packageInfo));
	                }
	            }
	            return packageInfo;
	        }
	    }

1. `getPackageInfo`首先判断了调用方和保存App信息的一方是否是同一个userID,如果是同一个user  那么就可以使用共享的缓存数据(要么缓存的代码数据,要么缓存的资源数据)

2. 然后尝试获取缓存数据,如果没有缓存数据,那么直接创建LoadedApk对象.并且在创建成功之后会放入缓存(会判断userid)

### 4.3.2  Hook点

**已经知道获取类加载器会优先从缓存中获取(这个缓存就是包名和LoadedApk的一个映射),这个保存缓存对象的数组是ActivityThread的成员变量,另外ActivityThread是唯一的,仅在进程初始化时 被创建一次,所以只需要hook掉这一个点, 就能对所有获取类加载器的地方都起作用**

	//ActivityThread
    @GuardedBy("mResourcesManager")
    final ArrayMap<String, WeakReference<LoadedApk>> mPackages = new ArrayMap<>();
    @GuardedBy("mResourcesManager")
    final ArrayMap<String, WeakReference<LoadedApk>> mResourcePackages = new ArrayMap<>();

## 4.4 Hook方案

根据之前的解决思路,可以有俩套方案去Hook 这个点:

1. 针对`mPackages`缓存进行Hook,将原始的`LoadedApk.getClassLoader()`方法进行Hook,使其能返回修改过的ClassLoader.这样在`perfromLaunchActivity()`中即可找到插件所在,并执行接下来的逻辑.

2. 通过Hook掉ClassLoader的`DexPathList`,将插件信息放入其中


# 5. 方案一

## 5.1 获取ArrayMap mPackages对象

首先需要获取到`获取ArrayMap mPackages`对象,因为需要借助这个对象去替换掉原先的`LoadedApk`,该对象存在于ActivityThread中.


## 5.2 往mPackages对象中插入修改过的LoadedApk

已经知道`mPackages`作为缓存使用,它是获取LoadedApk的重要媒介,并且在获取到`LoadedApk`之后,会获取`ClassLoader`.那么 第二步 就是需要获取到这个LoadedApk

这里有俩种方式去获取到`LoadedApk`:

1. `mPackages`中已经存在,那么直接提取出来用即可.**但是,LoadedApk 是一个隐藏类,且没有接口,无法创建代理**

2. 直接构建LoadedApk对象

## 5.3 构建LoadedApk

虽然可以直接通过反射调用它的构造函数直接创建出对象,但是这样对参数的准确性有很高的要求,一旦参数使用错误 可能就无法被系统所使用.

系统创建`LoadedApk`的方式 在4.3.1中已经分析过.**可以通过反射调用ActivityThread.getPackageInfoNoCheck()来获取到LoadedApk**,优先使用`getPackageInfoNoCheck()`而不使用`getPackageInfo()`是因为前者是 **公开的方法而后者是私有的方法,而且私有的方法很容易遭到修改**

    public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
            CompatibilityInfo compatInfo) {
        return getPackageInfo(ai, compatInfo, null, false, true, false);
    }

    private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
            ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
            boolean registerPackage) {

	}

- 为了调用`getPackageInfoNoCheck()`需要俩个参数,`ApplicationInfo`和`CompatibilityInfo`.

### 5.3.1 构建ApplicationInfo
ApplicationInfo的简介如下:

> Information you can retrieve about a particular application. 
>  This corresponds to information collected from the AndroidManifest.xml's &lt;application&gt; tag.
>  该类就是清单文件中application标签下的信息


**Android系统提供了`PackageParse`用来解析清单文件从而获得ApplicationInfo类(具体的代码可以在PMS中查看).但是这个类的兼容性很差!几乎每个Android版本都对应一种实现方式!!!**

**反射私有或隐藏API时,需要处理好兼容性问题 尽量反射那些公开的方法,字段 因为谷歌通常不会对这种 公有的方法,字段进行修改,但是也不绝对**
	
	//PackageParse.generateApplicationInfo()
    public static ApplicationInfo generateApplicationInfo(Package p, int flags,
            PackageUserState state) {
        return generateApplicationInfo(p, flags, state, UserHandle.getCallingUserId());
    }

- 要想调用这个方法,必须得准备好三个参数,`Package`,`flags`,`PackageUserState`

- 创建完ApplicationInfo之后,需要进行修改.因为通过系统默认方法得到的`ApplicationInfo`对象并没有apk文件本身的信息,所以需要设置一下apk的解析路径 

#### 5.3.1.1 Package
`Package`类是`PackageParser`的静态内部类.代表磁盘里的Apk文件解析出来的信息

> Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.

**`PackageParser.parsePackage()`方法是用来解析包的方法.**

> Parse the package at the given location. Automatically detects if the package is a monolithic style (single APK file) or cluster style (directory of APKs).

    public Package parsePackage(File packageFile, 
			int flags, boolean useCaches)
	{``省略代码```}

- 第一个参数是 apk文件,第二个参数是解析包的flag,选择0 表示解析所有

#### 5.3.1.2 flags

解析包使用的flag,传入0表示默认解析所有信息

#### 5.3.1.3 PackageUserState
Android系统是一个多任务多用户系统,因此不同的用户使用同一个包可能有不同的状态

>Per-user state information about a package.

查看其构造函数,发现并没有特殊的参数需要传入. 所以**这里传默认值即可,即直接调用构造函数创建...**

    public PackageUserState() {}

    public PackageUserState(PackageUserState o) {}


### 5.3.2 构建CompatilityInfo

> CompatibilityInfo class keeps the information about compatibility mode that the application is running under.

`CompatilityInfo`类中有一个静态变量`DEFAULT_COMPATIBILITY_INFO`代表默认兼容信息

	public class CompatibilityInfo implements Parcelable {
	    /** default compatibility info object for compatible applications */
	    public static final CompatibilityInfo DEFAULT_COMPATIBILITY_INFO = new CompatibilityInfo() {
	    };
	}

## 5.4 替换LoadedApk

# 6. 绕过检查