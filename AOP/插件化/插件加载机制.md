# 插件加载机制

[Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)

[ClassLoader原理学习.md](https://github.com/iwantthink/TODO/blob/master/AOP/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.md)

# 1. 简介

通常情况下,插件会以额外的文件 存在于assets目录 或者 从网络下载.**这里就涉及到了一个问题 如何将额外的class文件加载到内存中.例如启动一个Activity,之前已经解决了启动未在清单文件中声明的Activity(该Activity保存在同一个apk下).那么如果这个Activity存在于插件中,Activity是否能正确加载?**

**本文基于Android27**

# 2. 启动插件中的Activity会遇到的问题

## 2.1 正常Activity类的加载逻辑
Activity类对象的具体创建在`ActivityThread.performLaunchActivity()`方法中:

	ContextImpl appContext = createBaseContextForActivity(r);
	Activity activity = null;
	try {
		java.lang.ClassLoader cl = appContext.getClassLoader();
		activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
		``省略代码``
	} catch (Exception e) {
		``省略代码```
	}
	// Instrumentation.newActivity()
    public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        return (Activity)cl.loadClass(className).newInstance();
    }


- Android通过`ClassLoader`将目标类加载到内存中,然后通过反射调用构造函数将该类创建出来

- Activity创建过程中使用的ClassLoader就是`PathClassLoader`

		//ContextImpl.getClassLoader()
	    @Override
	    public ClassLoader getClassLoader() {
	        return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
	    }
		//ClassLoader
	    @CallerSensitive
	    public static ClassLoader getSystemClassLoader() {
	        return SystemClassLoader.loader;
	    }
		//ClassLoader
	    static private class SystemClassLoader {
	        public static ClassLoader loader = ClassLoader.createSystemClassLoader();
	    }
		//ClassLoader.createSystemClassLoader()
	    private static ClassLoader createSystemClassLoader() {
	        String classPath = System.getProperty("java.class.path", ".");
	        String librarySearchPath = System.getProperty("java.library.path", "");
	        return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
	    }

- **Android系统使用PathClassLoader来加载系统类和应用程序的类，如果是加载应用程序类，则会加载`data/app/`目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载哪种类型的文件，最终都是加载dex文件**

## 2.2 插件遇到的问题

Android系统使用ClassLoader机制去加载类,在Activity类的加载过程之中,使用了`PathClassLoader`类加载器. **这个类加载器有一个特点就是只能加载已安装应用的dex或apk文件**,插件大多不符合这个条件(插件位置是任意的),因此正常情况下系统无法加载插件中的类,也没办法创建插件中的Activity对象

# 3. ClassLoader机制介绍

具体的去看[ClassLoader原理学习.md](https://github.com/iwantthink/TODO/blob/master/AOP/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.md)

>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。**例如，如果编写一个面向接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中(动态加载)**。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。


Java类加载过程包括:加载,验证,准备,解析和初始化五个阶段,**加载阶段是最适合修改的地方**.加载阶段主要完成三件事:

1. 根据类的全限定名来获取定义此类的二进制字节流

2. 将这个字节流锁代表的静态存储结构转换为JVM方法区中的运行时数据结构

3. 在内存中生成一个代表这个类的`java.lang.Class`对象,作为方法区这个类的各种数据的访问入口

**Android中的ClassLoader:**

- **Android系统使用`PathClassLoader`来加载系统类和应用程序的类,其有一个限制:只能加载已安装应用的dex或apk文件.**

- **另外还提供了`DexClassLoader`,可以用来加载不能用`PathClassLoader`加载的类**


# 4. 如何加载插件?

## 4.1 解决思路

之前已经提到 插件的类无法被`PathClassLoader`加载,那么解决这个问题有俩个方式:

1. 全面接管系统的类加载过程,添加一个加载插件`DexClassLoader`.

	这种方案就需要往`ArrayMap mPackages`中添加能加载 插件的`LoadedApk`,这样在寻找类对应加载器时 找到的就是手动添加的那个类加载器(**另外还需要将启动Activity的Intent 中的PKG信息 换成能加载 指定类加载器的**)

2. 将插件位置告诉系统类加载器,让系统帮忙加载



- **这俩种方式都需要干预类加载这个过程**

## 4.2 Activity加载所使用的ClassLoader

1. `ActivityThread.performLaunchActivity()`

		ContextImpl appContext = createBaseContextForActivity(r);
		java.lang.ClassLoader cl = appContext.getClassLoader();

	- 具体的类加载器 是交给`ContextImpl`来实现的

2. `ContextImpl.getClassLoader()`

	    @Override
	    public ClassLoader getClassLoader() {
	        return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
	    }

	- **`mClassLoader`是ClassLoader的缓存.**
	
	- `mPackageInfo`是`LoadedApk`类型,从构造函数中传入(ContextImpl在`ActivityThread.performLaunchActivity().createBaseContextForActivity()`中被创建),可能为空(被`@Nullable`修饰)

	**`LoadedApk`对象是APK文件在内存中的表示.APk文件的相关信息,比如Apk文件的代码和资源,更具体点就是代码里面的Activity,Service等组件的信息.在ActivityThread.H 的 handleMessage(LAUNCH_ACTIVITY)中被创建 **

			//LoadedApk
			Local state maintained about a currently loaded .apk.

- 通过`LoadedApk`获取类加载器:

	    private void createOrUpdateClassLoaderLocked(List<String> addedPaths) {
			``省略代码``
	        if (mClassLoader == null) {
	            // Temporarily disable logging of disk reads on the Looper thread
	            // as this is early and necessary.
				//最终返回的是PathClassLoader
	            mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip,
	                    mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,
	                    libraryPermittedPath, mBaseClassLoader,
	                    mApplicationInfo.classLoaderName);
	        }
	    }
	
	    public ClassLoader getClassLoader() {
	        synchronized (this) {
	            if (mClassLoader == null) {
	                createOrUpdateClassLoaderLocked(null /*addedPaths*/);
	            }
	            return mClassLoader;
	        }
	    }

- 通过`ClassLoader`获取类加载器:

	    @CallerSensitive
	    public static ClassLoader getSystemClassLoader() {
	        return SystemClassLoader.loader;
	    }

	    static private class SystemClassLoader {
	        public static ClassLoader loader = ClassLoader.createSystemClassLoader();
	    }

	    private static ClassLoader createSystemClassLoader() {
	        String classPath = System.getProperty("java.class.path", ".");
	        String librarySearchPath = System.getProperty("java.library.path", "");
	        return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
	    }

**Activity所用的类加载器获取总结:**

- **ClassLoader优先从缓存中获取,没有缓存则通过`LoadedApk`获取,没有`LoadedApk`则通过`ClassLoader`获取**.**通过`LoadedApk`最终也是通过`ClassLoader`获取类加载器**

## 4.3 Hook点分析

已经知道类加载器的获取会优先借助`LoadedApk`(`LoadedApk.getClassLoader()`),其次再是直接通过`ClassLoader`获取.

那么查看一下`LoadedApk`的生成方式,查看是否能够借助这个类来实现对`ClassLoader`的修改

### 4.3.1 LoadedApk的创建方式

在`ActivityThread.mH.handleMessage()`的`LAUNCH_ACTIVITY`中查看到 `LoadedApk`的首次创建

		case LAUNCH_ACTIVITY: {
		
			final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
			r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
			handleLaunchActivity(r, null, "LAUNCH_ACTIVITY");
	
		} break;
		
	    public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
	            CompatibilityInfo compatInfo) {
	        return getPackageInfo(ai, compatInfo, null, false, true, false);
	    }

	    private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
	            ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
	            boolean registerPackage) {
			//获取当前进程的userid,并判断是否是同一个进程
	        final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));
	        synchronized (mResourcesManager) {
				//根据 userid 获取缓存信息
	            WeakReference<LoadedApk> ref;
	            if (differentUser) {
	                // Caching not supported across users
	                ref = null;
				//includeCode = true
	            } else if (includeCode) {
	                ref = mPackages.get(aInfo.packageName);
	            } else {
	                ref = mResourcePackages.get(aInfo.packageName);
	            }
	
	            LoadedApk packageInfo = ref != null ? ref.get() : null;
	            if (packageInfo == null || (packageInfo.mResources != null
	                    && !packageInfo.mResources.getAssets().isUpToDate())) {
					//缓存不存在,直接创建
	                packageInfo =
	                    new LoadedApk(this, aInfo, compatInfo, baseLoader,
	                            securityViolation, includeCode &&
	                            (aInfo.flags&ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);
					//存入缓存,与保存类的文件名 相匹配
	                if (mSystemThread && "android".equals(aInfo.packageName)) {
	                    packageInfo.installSystemApplicationInfo(aInfo,
	                            getSystemContext().mPackageInfo.getClassLoader());
	                }
	
	                if (differentUser) {
	                    // Caching not supported across users
	                } else if (includeCode) {
	                    mPackages.put(aInfo.packageName,
	                            new WeakReference<LoadedApk>(packageInfo));
	                } else {
	                    mResourcePackages.put(aInfo.packageName,
	                            new WeakReference<LoadedApk>(packageInfo));
	                }
	            }
	            return packageInfo;
	        }
	    }

1. `getPackageInfo`首先判断了调用方和保存App信息的一方是否是同一个userID,如果是同一个user  那么就可以使用共享的缓存数据(要么缓存的代码数据,要么缓存的资源数据)

2. 然后尝试获取缓存数据,如果没有缓存数据,那么直接创建LoadedApk对象.并且在创建成功之后会放入缓存(会判断userid)

3. **注意,`LoadedApk`是通过包名获取的,如果想要获得指定的`LoadedApk`就需要传入指定的 包名!!!!!!,这点非常重要**

	**如果想要获取到 加载插件的LoadedApk 那就必须传入 其对应的 包名,那就要求在绕过AMS检查之后,替换Intent的时候 将加载插件类加载器 对应的包名 替换掉之前Intent中的包名, 查看代码这个值应该是保存在`LoadedApk.ApplicationInfo`**


### 4.3.2  Hook点

**已经知道获取类加载器会优先从缓存中获取(这个缓存就是包名和LoadedApk的一个映射),这个保存缓存对象的数组是ActivityThread的成员变量,另外ActivityThread是唯一的,仅在进程初始化时 被创建一次,所以只需要hook掉这一个点, 就能对所有获取类加载器的地方都起作用**

	//ActivityThread
    @GuardedBy("mResourcesManager")
    final ArrayMap<String, WeakReference<LoadedApk>> mPackages = new ArrayMap<>();
    @GuardedBy("mResourcesManager")
    final ArrayMap<String, WeakReference<LoadedApk>> mResourcePackages = new ArrayMap<>();

- **`mPackages`中保存的是 关系是: 包名-LoadedApk**,插件如果是`.dex`形式,那么可能无法进行Hook(无法构建LoadedApk,缺少信息). 

## 4.4 Hook方案

根据之前的解决思路,可以有俩套方案去Hook 这个点:

1. 往`mPackages`中添加 新的 插件包名-代表插件信息的`LoadedApk` ,将`LoadedApk.getClassLoader()`方法进行Hook,使其能返回修改过的`DexClassLoader`.这样在`perfromLaunchActivity()`中即可使用`DexClassLoader`去加载插件.

2. 通过Hook掉系统的`PathClassLoader`的`DexPathList`,将插件信息放入其中,使得系统类加载能够找到插件所在,从而完成加载


# 5. 方案一
**注意:这种方案 需要插件的形式为 `.apk`文件,因为只有apk文件才含有这种方案所需的信息**
## 5.1 获取ArrayMap mPackages对象

首先需要获取到`ArrayMap mPackages`对象,因为需要借助这个对象去添加新的`LoadedApk`,该对象存在于`ActivityThread`中.

**具体代码:**

	//获取ActivityThread 的字节码
	Class activityThread_class = Class.forName("android.app.ActivityThread");
	//获取ActivityThread.sCurrentActivityThread 字段
	Field sCurrentActivityThread_field = activityThread_class.getDeclaredField("sCurrentActivityThread");
	sCurrentActivityThread_field.setAccessible(true);
	//获取ActivityThread 对象
	Object sCurrentActivityThread = sCurrentActivityThread_field.get(null);
	//获取ActivityThread.mPackages字段
	Field mPackages_field = activityThread_class.
                    getDeclaredField("mPackages");
	mPackages_field.setAccessible(true);
	//ArrayMap<String, WeakReference<LoadedApk>> mPackages
	ArrayMap mPackages = (ArrayMap) mPackages_field.get(sCurrentActivityThread);

## 5.2 往mPackages对象中插入修改过的LoadedApk

已经知道`ArrayMap mPackages`会储存LoadedApk,而`LoadedApk`对象里的`mClassLoader`变量 就是实际的类加载器.那么只要获取到这个`LoadedApk`并替换掉其`mClassLoader`即可解决无法加载插件类的问题

**获取`LoadedApk`的方式:**

1. `mPackages`中不存在插件包名对应的 类加载器,只存在当前宿主的类加载器.

2. 构建LoadedApk对象,**这里需要注意,直接创建的`LoadedApk`会缺少一些参数,我们需要手动替他添加**


**具体代码:**

	//更新ActivityThread中的mPackages
	mPackages_field.set(sCurrentActivityThread, mPackages);

## 5.3 构建LoadedApk

**虽然可以直接通过反射调用它的构造函数直接创建出对象,但是这样对参数的准确性有很高的要求,一旦参数使用错误 可能就无法被系统所使用.**

系统创建`LoadedApk`的方式 在4.3.1中已经分析过.**可以通过反射调用ActivityThread.getPackageInfoNoCheck()来获取到LoadedApk**,优先使用`getPackageInfoNoCheck()`而不使用`getPackageInfo()`是因为前者是 **公开的方法而后者是私有的方法,而且私有的方法很容易遭到修改**

    public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
            CompatibilityInfo compatInfo) {
        return getPackageInfo(ai, compatInfo, null, false, true, false);
    }

    private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
            ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
            boolean registerPackage) {

	}

- 为了调用`getPackageInfoNoCheck()`需要俩个参数,`ApplicationInfo`和`CompatibilityInfo`.


**具体代码:**

	//获取CompatibilityInfo的字节码,用于反射获取`getPackageInfoNoCheck()`方法
	Class compatibilityInfo = Class.forName("android.content.res.CompatibilityInfo");
	//获取getPackageInfoNoCheck方法
	Method getPackageInfoNoCheck_method = activityThread_class.getDeclaredMethod(
                    "getPackageInfoNoCheck",
                    ApplicationInfo.class,
                    compatibilityInfo);
	getPackageInfoNoCheck_method.setAccessible(true);
	//获取ApplicationInfo,插件的
	ApplicationInfo applicationInfo = (ApplicationInfo) getLocalApplicationInfo(apkFile);
	//获取CompatibilityInfo
	Object DEFAULT_COMPATIBILITY_INFO = getCompatibilityInfo();
	//创建LoadedApk
	Object loadedApk = getPackageInfoNoCheck_method.invoke(
                    sCurrentActivityThread,
                    applicationInfo,
                    DEFAULT_COMPATIBILITY_INFO);

- 具体的俩个参数如何创建,在5.3.1 , 5.3.2

### 5.3.1 构建ApplicationInfo
ApplicationInfo的简介如下:

> Information you can retrieve about a particular application. 
>  This corresponds to information collected from the AndroidManifest.xml's &lt;application&gt; tag.
>  该类就是清单文件中application标签下的信息


**Android系统提供了`PackageParse`用来解析清单文件从而获得ApplicationInfo类(具体的代码可以在PMS中查看).但是这个类的兼容性很差!几乎每个Android版本都对应一种实现方式!!!**

**反射私有或隐藏API时,需要处理好兼容性问题 尽量反射那些公开的方法,字段 因为谷歌通常不会对这种 公有的方法,字段进行修改,但是也不绝对**
	
	//PackageParse.generateApplicationInfo()
    public static ApplicationInfo generateApplicationInfo(Package p, int flags,
            PackageUserState state) {
        return generateApplicationInfo(p, flags, state, UserHandle.getCallingUserId());
    }

- 要想调用这个方法,必须得准备好三个参数,`Package`,`flags`,`PackageUserState`

- 创建完ApplicationInfo之后,需要进行修改.因为通过系统默认方法得到的`ApplicationInfo`对象并没有apk文件本身的信息,所以需要设置一下apk的解析路径 

**构建ApplicationInfo的具体代码:**

	//分别获取 PackageParser,PackageParser$Package,PackageUserState 的字节码
	Class packageParser_class = Class.forName("android.content.pm.PackageParser");
	Class package_class = Class.forName("android.content.pm.PackageParser$Package");
	Class packageUserState_class = Class.forName("android.content.pm.PackageUserState");

	//获取`parsePackage`方法,用来获取创建ApplicationInfo时 所需的Package参数
	Method parsePackage_method = packageParser_class.
                    getDeclaredMethod("parsePackage", File.class, int.class);
	parsePackage_method.setAccessible(true);
	Object package_obj = parsePackage_method.invoke(
                    packageParser_class.newInstance(),
                    apkFile,
                    0);
	//获取`generateApplicationInfo`方法,用来创建ApplicationInfo
	Method generateApplicationInfo_method = packageParser_class.                    getDeclaredMethod("generateApplicationInfo",
                            package_class,
                            int.class,
                            packageUserState_class);
	generateApplicationInfo_method.setAccessible(true);
	ApplicationInfo applicationInfo = (ApplicationInfo) generateApplicationInfo_method.invoke(null,
                    package_obj, 0,
                    packageUserState_class.newInstance());
	//ApplicationInfo 虽然被创建了,但是apk路径仍然为空
	applicationInfo.sourceDir = apkFile.getPath();
	applicationInfo.publicSourceDir = apkFile.getPath();


- `sourceDir`和`publicSourceDir`参考:

	    /**
	     * Full path to the base APK for this application.
	     */
	    public String sourceDir;
	
	    /**
	     * Full path to the publicly available parts of {@link #sourceDir},
	     * including resources and manifest. This may be different from
	     * {@link #sourceDir} if an application is forward locked.
	     */
	    public String publicSourceDir;


#### 5.3.1.1 Package
`Package`类是`PackageParser`的静态内部类.代表磁盘里的Apk文件解析出来的信息

> Representation of a full package parsed from APK files on disk. A package consists of a single base APK, and zero or more split APKs.

**`PackageParser.parsePackage()`方法是用来解析包的方法.**

> Parse the package at the given location. Automatically detects if the package is a monolithic style (single APK file) or cluster style (directory of APKs).

    public Package parsePackage(File packageFile, 
			int flags, boolean useCaches)
	{``省略代码```}

- 第一个参数是 apk文件,第二个参数是解析包的flag,选择0 表示解析所有

#### 5.3.1.2 flags

解析包使用的flag,传入0表示默认解析所有信息

#### 5.3.1.3 PackageUserState
Android系统是一个多任务多用户系统,因此不同的用户使用同一个包可能有不同的状态

>Per-user state information about a package.

查看其构造函数,发现并没有特殊的参数需要传入. 所以**这里传默认值即可,即直接调用构造函数创建...**

    public PackageUserState() {}

    public PackageUserState(PackageUserState o) {}


### 5.3.2 构建CompatilityInfo

> CompatibilityInfo class keeps the information about compatibility mode that the application is running under.

`CompatilityInfo`类中有一个静态变量`DEFAULT_COMPATIBILITY_INFO`代表默认兼容信息

	public class CompatibilityInfo implements Parcelable {
	    /** default compatibility info object for compatible applications */
	    public static final CompatibilityInfo DEFAULT_COMPATIBILITY_INFO = new CompatibilityInfo() {
	    };
	}

**`CompatilityInfo`具体创建代码:**

	Class compatibilityInfo = Class.forName("android.content.res.CompatibilityInfo");
	Field DEFAULT_COMPATIBILITY_INFO_field = compatibilityInfo.
                getDeclaredField("DEFAULT_COMPATIBILITY_INFO");
	DEFAULT_COMPATIBILITY_INFO_field.setAccessible(true);

## 5.4 替换LoadedApk中的ClassLoader

`LoadedApk`已经被创建好.但是类并不是由`LoadedApk`加载,而是由其成员变量`mClassLoader`加载.所以为了加载成功,还需要替换掉 这个变量

	//替换LoadedApk中的ClassLoader
	Field mClassLoader_Field = loadedApk.getClass().
                    getDeclaredField("mClassLoader");
	mClassLoader_Field.setAccessible(true);
	DexClassLoader dexClassLoader = new DexClassLoader(apkFile.getAbsolutePath(),
                    getPluginOptDirPath(),
                    getPluginLibSearchPath(),
                    ClassLoader.getSystemClassLoader());
	mClassLoader_Field.set(loadedApk, dexClassLoader);

- 关于`DexClassLoader`所需的参数...直接去看`[ClassLoader原理学习.md]`即可

## 5.5 替换LoadedApk
至此,真正能够实现加载插件类的`LoadedApk`已经被创建出来,只需要将其放入`mPackages`即可

	//替换mPackages中的 loadedapk
	mPackages.put(applicationInfo.packageName, new WeakReference(loadedApk));
	mPackages_field.set(sCurrentActivityThread, mPackages);

- 注意 `LoadedApk`被虚引用包装

# 6. 方案一:完整逻辑

1. 默认打开一个 插件中的 未在清单文件中注册的`Activity:FakeActivity`

		startActivity(new Intent(MainActivity.this, FakeActivity.class));

2. 需要Hook掉`AMS.startActivity()`的方法, 将`FakeActivity`替换成`MainActivity`(即在替换成在清单文件中注册过的Activity,绕开检查)
		Class acitivtyManagerNativeClass = Class.forName("android.app.ActivityManagerNative");
		Field gDefaultField = acitivtyManagerNativeClass.getDeclaredField("gDefault");
		gDefaultField.setAccessible(true);
		Object gDefault = gDefaultField.get(null);

		Class singleTonClass = Class.forName("android.util.Singleton");
		Field mInstanceField = singleTonClass.getDeclaredField("mInstance");
		mInstanceField.setAccessible(true);

		//获取到了IActivityManager.即Binder.Stub.Proxy
		Object mInstance = mInstanceField.get(gDefault);

		Object newInstance = Proxy.newProxyInstance(mInstance.getClass().getClassLoader(),
                    new Class[]{IBinder.class,
                            IInterface.class,
                            Class.forName("android.app.IActivityManager")},
                    new ActivityProxy(mInstance));

		mInstanceField.set(gDefault, newInstance);

	**ActivityProxy**

		public class ActivityProxy implements InvocationHandler {
		
		    private Object mBase;
		
		    public ActivityProxy(Object base) {
		        mBase = base;
		    }
		
		    @Override
		    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		        Log.d("ActivityProxy", "hello ? " + method.getName() + ",do something");
		        if (method.getName().equals("startActivity")) {
		
		        }
		
		        return method.invoke(mBase, args);
		    }
		}

3. 需要Hook掉`ActivityThread.H.handleMessage()`,将已绕过AMS检查的Intent 中的 信息替换掉.**另外 必须得将activityInfo所带的包名 修改掉,这样才能在`ActivityThread.mPackages`中找到对应的`LoadedApk`**

		//获取ActivityThread对象
		Class class_activityThread = Class.forName("android.app.ActivityThread");
		Method method_currentActivityThread = class_activityThread.getMethod("currentActivityThread",
                    new Class[]{});
		method_currentActivityThread.setAccessible(true);
		Object activityThread = method_currentActivityThread.invoke(null, new Object[]{});

		//获取mH 这个Handler
		Field mHField = class_activityThread.getDeclaredField("mH");
		//这一步是为了绕过Java检查，而不是将修饰符修改成public
		mHField.setAccessible(true);
		Object mH = mHField.get(activityThread);

		//获取mH 中的mCallback对象
		Field field_callBack = Handler.class.getDeclaredField("mCallback");
		field_callBack.setAccessible(true);
		// 给mCallback设置回调
		field_callBack.set(mH, mDispatcher);

	    public Handler.Callback mDispatcher = new Handler.Callback() {
	        @Override
	        public boolean handleMessage(Message msg) {
	            if (msg.what == 100) {
	                Object record = msg.obj;
	                try {
	                    Field intentField = record.getClass().getDeclaredField("intent");
	                    intentField.setAccessible(true);
	                    Intent intent = (Intent) intentField.get(record);
	                    Log.d("mDispatcher", intent.getComponent().getClassName());
	                    Log.d("mDispatcher", intent.getComponent().getPackageName());
						//if (intent.hasExtra("TARGET_INTENT")) {
	                    if (intent.getComponent().getClassName().equals("com.ryan.hotfix.MainActivity")) {
	                        Intent realIntent = new Intent();
	                        realIntent.setComponent(new ComponentName(
	                                "com.ryan.ndksample",                               "com.ryan.ndksample.MainActivity"));
	                        intentField.set(record, realIntent);
	
	                        Field activityInfoField = msg.obj.getClass().getDeclaredField("activityInfo");
	                        activityInfoField.setAccessible(true);
	
	                        // 根据 getPackageInfo 根据这个 包名获取 LoadedApk的信息; 因此这里我们需要手动填上, 从而能够命中缓存
	                        ActivityInfo activityInfo = (ActivityInfo) activityInfoField.get(msg.obj);
	                        activityInfo.applicationInfo.packageName = realIntent.getPackage() == null ?
	                                realIntent.getComponent().getPackageName() : realIntent.getPackage();
	                    }
	                } catch (Exception e) {
	                    e.printStackTrace();
	                }
	            }
	            return false;
	        }
	    };

4. Hook掉mPackages,根据插件信息生成一个`LoadedApk` 放入`ArrayMap mPackages`

            //获取到mPackages
            Class activityThread_class = Class.forName("android.app.ActivityThread");
            Field sCurrentActivityThread_field = activityThread_class.
                    getDeclaredField("sCurrentActivityThread");
            sCurrentActivityThread_field.setAccessible(true);
            Object sCurrentActivityThread = sCurrentActivityThread_field.get(null);

            Field mPackages_field = activityThread_class.
                    getDeclaredField("mPackages");
            mPackages_field.setAccessible(true);
            //ArrayMap<String, WeakReference<LoadedApk>> mPackages
            ArrayMap mPackages = (ArrayMap) mPackages_field.get(sCurrentActivityThread);

            Class compatibilityInfo = Class.forName("android.content.res.CompatibilityInfo");

            Method getPackageInfoNoCheck_method = activityThread_class.getDeclaredMethod(
                    "getPackageInfoNoCheck",
                    ApplicationInfo.class,
                    compatibilityInfo);
            getPackageInfoNoCheck_method.setAccessible(true);

            //获取ApplicationInfo,插件的
            ApplicationInfo applicationInfo = (ApplicationInfo) getLocalApplicationInfo(apkFile);

            //获取CompatibilityInfo
            Object DEFAULT_COMPATIBILITY_INFO = getCompatibilityInfo();
            //获取LoadedApk
            Object loadedApk = getPackageInfoNoCheck_method.invoke(
                    sCurrentActivityThread,
                    applicationInfo,
                    DEFAULT_COMPATIBILITY_INFO);

            //替换LoadedApk中的ClassLoader
            Field mClassLoader_Field = loadedApk.getClass().
                    getDeclaredField("mClassLoader");
            mClassLoader_Field.setAccessible(true);
            DexClassLoader dexClassLoader = new DexClassLoader(apkFile.getAbsolutePath(),
                    getPluginOptDirPath(),
                    getPluginLibSearchPath(),
                    ClassLoader.getSystemClassLoader());

            mClassLoader_Field.set(loadedApk, dexClassLoader);
            //替换mPackages中的 loadedapk
            mPackages.put(applicationInfo.packageName, new WeakReference(loadedApk));

            mPackages_field.set(sCurrentActivityThread, mPackages);
	
	**获取CompatibilityInfo**

	    private Object getCompatibilityInfo() throws Exception {
	        Class compatibilityInfo = Class.forName("android.content.res.CompatibilityInfo");
	        Field DEFAULT_COMPATIBILITY_INFO_field = compatibilityInfo.
	                getDeclaredField("DEFAULT_COMPATIBILITY_INFO");
	        DEFAULT_COMPATIBILITY_INFO_field.setAccessible(true);
	        return DEFAULT_COMPATIBILITY_INFO_field.get(null);
	    }

	**获取ApplicationInfo**

	    public Object getLocalApplicationInfo(File apkFile) {
	        try {
	            Class packageParser_class = Class.forName("android.content.pm.PackageParser");
	            Class package_class = Class.forName("android.content.pm.PackageParser$Package");
	            Class packageUserState_class = Class.forName("android.content.pm.PackageUserState");
	
	            Method parsePackage_method = packageParser_class.
	                    getDeclaredMethod("parsePackage", File.class, int.class);
	            parsePackage_method.setAccessible(true);
	            Object package_obj = parsePackage_method.invoke(
	                    packageParser_class.newInstance(),
	                    apkFile,
	                    0);
	
	            Method generateApplicationInfo_method = packageParser_class.
	                    getDeclaredMethod("generateApplicationInfo",
	                            package_class,
	                            int.class,
	                            packageUserState_class);
	            generateApplicationInfo_method.setAccessible(true);
	            ApplicationInfo applicationInfo = (ApplicationInfo) generateApplicationInfo_method.invoke(null,
	                    package_obj, 0,
	                    packageUserState_class.newInstance());
	            applicationInfo.sourceDir = apkFile.getPath();
	            applicationInfo.publicSourceDir = apkFile.getPath();
	
	            return applicationInfo;
	        } catch (Exception e) {
	            Log.e("MainActivity", "getLocalApplicationInfo = " + e.getMessage());
	        }
	        return null;
	    }


# 7. 不同版本上的问题

上面的代码,在Android 22 上是能够正确执行.但是在Android 24 上是会抛出一个异常

	Caused by: java.lang.IllegalStateException: Unable to get package info for com.ryan.ndksample; is package not installed?
		at android.app.LoadedApk.initializeJavaContextClassLoader(LoadedApk.java:636)
		at android.app.LoadedApk.makeApplication(LoadedApk.java:796)
		at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2597) 
		at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2749) 
		at android.app.ActivityThread.-wrap12(ActivityThread.java) 
		at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1498) 

## 7.1 异常发生的地方(Android 24)

    private void initializeJavaContextClassLoader() {
        IPackageManager pm = ActivityThread.getPackageManager();
        android.content.pm.PackageInfo pi;
        try {
            pi = pm.getPackageInfo(mPackageName, PackageManager.MATCH_DEBUG_TRIAGED_MISSING, UserHandle.myUserId());
        } catch (RemoteException e) {
            throw new IllegalStateException("Unable to get package info for "
                    + mPackageName + "; is system dying?", e);
        }
        if (pi == null) {
            throw new IllegalStateException("Unable to get package info for "
                    + mPackageName + "; is package not installed?");
        }
		``省略代码```
    }

- 可以看到上述代码在获取PackageInfo的过程中,因为获取为空,所以抛出了这个异常

查看`PackageManagerService.getPackageInfo()`....


    @Override
    public PackageInfo getPackageInfo(String packageName, int flags, int userId) {
        if (!sUserManager.exists(userId)) return null;
        flags = updateFlagsForPackage(flags, userId, packageName);
        enforceCrossUserPermission(Binder.getCallingUid(), userId,
                false /* requireFullPermission */, false /* checkShell */, "get package info");
        // reader
        synchronized (mPackages) {
            final boolean matchFactoryOnly = (flags & MATCH_FACTORY_ONLY) != 0;
            PackageParser.Package p = null;
            if (matchFactoryOnly) {
                final PackageSetting ps = mSettings.getDisabledSystemPkgLPr(packageName);
                if (ps != null) {
                    return generatePackageInfo(ps, flags, userId);
                }
            }
            if (p == null) {
                p = mPackages.get(packageName);
                if (matchFactoryOnly && p != null && !isSystemApp(p)) {
                    return null;
                }
            }
            if (DEBUG_PACKAGE_INFO)
                Log.v(TAG, "getPackageInfo " + packageName + ": " + p);
            if (p != null) {
                return generatePackageInfo((PackageSetting)p.mExtras, flags, userId);
            }
            if (!matchFactoryOnly && (flags & MATCH_UNINSTALLED_PACKAGES) != 0) {
                final PackageSetting ps = mSettings.mPackages.get(packageName);
                return generatePackageInfo(ps, flags, userId);
            }
        }
        return null;
    }

## 7.2 解决办法(具体分析等分析完PMS之后再来)

    // 这一步是因为 initializeJavaContextClassLoader 这个方法内部无意中检查了这个包是否在系统安装
    // 如果没有安装, 直接抛出异常, 这里需要临时Hook掉 PMS, 绕过这个检查.

    Class<?> activityThreadClass = Class.forName("android.app.ActivityThread");
    Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod("currentActivityThread");
    currentActivityThreadMethod.setAccessible(true);
    Object currentActivityThread = currentActivityThreadMethod.invoke(null);

    // 获取ActivityThread里面原始的 sPackageManager
    Field sPackageManagerField = activityThreadClass.getDeclaredField("sPackageManager");
    sPackageManagerField.setAccessible(true);
    Object sPackageManager = sPackageManagerField.get(currentActivityThread);

    // 准备好代理对象, 用来替换原始的对象
    Class<?> iPackageManagerInterface = Class.forName("android.content.pm.IPackageManager");
    Object proxy = Proxy.newProxyInstance(iPackageManagerInterface.getClassLoader(),
            new Class<?>[] { iPackageManagerInterface },
            new IPackageManagerHookHandler(sPackageManager));

    // 1. 替换掉ActivityThread里面的 sPackageManager 字段
    sPackageManagerField.set(currentActivityThread, proxy);

# 8. 方案二

通过Hook掉系统的`PathClassLoader`的`DexPathList`,将插件信息放入其中,使得系统类加载能够找到插件所在,从而完成加载

## 8.1 加载流程分析

由于默认的包名 对应的 类加载器的加载路径并不包含 插件,所以 方案一采用的解决办法是 手动构造一个`LoadedApk`(其实现的功能是返回指定`DexClassLoader`),并放入缓存中.这样在加载插件中类的时候,就会通过这个`DexClassLoader`

**那么如果不通过这种方式去加载类,默认的类加载器 到底做了些什么?**

	//ContextImpl
    @Override
    public ClassLoader getClassLoader() {
        return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
    }

- 系统使用的`ClassLoader` 分别从三个地方获取,`LoadedApk` 或`ClassLoader`本身或缓存`mClassLoader`

	**优先程度:`mClassLoader`>`LoadedApk`>`ClassLoader`**

## 8.2 ContextImpl mClassLoader

系统类加载最优先获取的是 `mClassLoader`这个值,那么确认一下这个值是否为空?如果为空就好办 直接去分析`LoadedApk`即可.

`ClassLoader mClassLoader`是`ContextImpl`的成员变量. 那么看一下`ContextImpl`的创建过程

1. `ActivityThread.performLaunchActivity()`方法中创建了Activity对应的ContextImpl

		ContextImpl appContext = createBaseContextForActivity(r);

2. `ActivityThread.createBaseContextForActivity()`直接调用`ContextImpl`自身的方法去创建自身

		ContextImpl appContext = ContextImpl.createActivityContext(
                this, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);

3. `ContextImpl.createActivityContext()`

	    static ContextImpl createActivityContext(ActivityThread mainThread,
	            LoadedApk packageInfo, ActivityInfo activityInfo, IBinder activityToken, int displayId,
	            Configuration overrideConfiguration) {

	        ClassLoader classLoader = packageInfo.getClassLoader();
	
	        ContextImpl context = new ContextImpl(null, mainThread, packageInfo, activityInfo.splitName,
	                activityToken, null, 0, classLoader);
		}

	这个方法里做了很重要的俩件事:

	1. **通过`LoadedApk`创建了一个`ClassLoader`,这个`LoadedApk`是在`ActivityThread.H.handleMessage(LAUNCH_ACTIVITY)`中被创建的**

	2. 调用构造函数创建了 `ContextImpl`

4. `ContextImpl`的构造函数

	    private ContextImpl(@Nullable ContextImpl container, @NonNull ActivityThread mainThread,
	            @NonNull LoadedApk packageInfo, @Nullable String splitName,
	            @Nullable IBinder activityToken, @Nullable UserHandle user, int flags,
	            @Nullable ClassLoader classLoader) {
	
	        mPackageInfo = packageInfo;
	
	        mClassLoader = classLoader;
	
		}

	- **从这里可以知道,默认的`mCLassLoader`不为空,它的值是通过`LoadedApk`获取的一个类加载器**


**至此,可以知道`mClassLoader`并不为空,它的值是通过`LoadedApk`获取的.参考 4.2 可以知道 获取到的是`PathClassLoader`**


## 8.3 系统ClassLoader是唯一的吗?

系统获取类加载器是通过`LoadedApk`,`LoadedApk`都是通过`ApplicationLoaders.getDefault().getClassLoader()`获取的`ClassLoader`,查看其具体实现 可以发现都是同一个类加载器.**那么只需要将这个类加载器 Hook掉,即对所有的类加载器过程起作用**


## 8.4 PathClassLoader 具体如何加载类?

在获取到`PathClassLoader`之后,会借助`Instrumentation`来加载类,实际上只是调用`PathClassLoader`的`loadClass()`方法

    public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        return (Activity)cl.loadClass(className).newInstance();
    }

类加载器的源码在`android.jar`之中,其线上源码在[DexClassLoader/PathClassLoader 源码地址](https://android.googlesource.com/platform/libcore/+/master/dalvik/src/main/java/dalvik/system)

### 8.4.1 PathClassLoader 源码

实际上,PathClassLoader仅仅是实现了其构造函数,主要功能的实现在`BaseDexClassLoader`

	public class PathClassLoader extends BaseDexClassLoader {
	
	    public PathClassLoader(String dexPath, ClassLoader parent) {
	        super(dexPath, null, null, parent);
	    }
	
	    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {
	        super(dexPath, null, librarySearchPath, parent);
	    }
	}

### 8.4.2 loadClass流程

**ClassLoader**

查看过`BaseDexClassLoader`的源码之后,就能发现其基本上是借助`DexPathList`实现

	//ClassLoader
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
	//ClassLoader
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
	//ClassLoader
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }

- `findClass(name)`是当前类加载器去执行加载操作的地方,在`ClassLoader`类中是抽象的,由`BaseDexClassLoader`类继承并实现

**BaseDexClassLoader**

	//BaseDexClassLoader
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        List<Throwable> suppressedExceptions = new ArrayList<Throwable>();
        Class c = pathList.findClass(name, suppressedExceptions);
        if (c == null) {
            ClassNotFoundException cnfe = new ClassNotFoundException(
                    "Didn't find class \"" + name + "\" on path: " + pathList);
            for (Throwable t : suppressedExceptions) {
                cnfe.addSuppressed(t);
            }
            throw cnfe;
        }
        return c;
    }

- `findClass()`方法只是将查找类的操作转交给`pathList`,`pathList`是`DexPathList`类型

**DexPathList**

    /**
     * Finds the named class in one of the dex files pointed at by
     * this instance. This will find the one in the earliest listed
     * path element. If the class is found but has not yet been
     * defined, then this method will define it in the defining
     * context that this instance was constructed with.
     * /

    public Class<?> findClass(String name, List<Throwable> suppressed) {
        for (Element element : dexElements) {
            Class<?> clazz = element.findClass(name, definingContext, suppressed);
            if (clazz != null) {
                return clazz;
            }
        }
        if (dexElementsSuppressedExceptions != null) {
            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));
        }
        return null;
    }

- **这个方法会根据给定的类名称,在指定的`.dex`文件中查找.会优先取出数组最靠前的一个.如果该类尚未定义,则会去定义它**

**Element**

	public Class<?> findClass(String name, 
		ClassLoader definingContext,
		List<Throwable> suppressed) {
		return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null;
	}

**DexFile**

    public Class loadClassBinaryName(String name, ClassLoader loader, List<Throwable> suppressed) {
        return defineClass(name, loader, mCookie, this, suppressed);
    }

    private static Class defineClass(String name, ClassLoader loader, Object cookie,
                                     DexFile dexFile, List<Throwable> suppressed) {
        Class result = null;
        try {
            result = defineClassNative(name, loader, cookie, dexFile);
        } catch (NoClassDefFoundError e) {
            if (suppressed != null) {
                suppressed.add(e);
            }
        } catch (ClassNotFoundException e) {
            if (suppressed != null) {
                suppressed.add(e);
            }
        }
        return result;
    }

- 最终是通过 本地方法 加载`.dex`文件中的类

## 8.5 Hook点分析

通过7.4.2 的分析, `PathClassLoader.loadClass()`最终会交给`DexPathList.findClass()`,在`DexPathList.findClass()`方法中 有遍历`Element`数组 去加载类(**这个`Element`保存有dex/resource的路径等信息**)

**同时有一点很重要,那就是`DexPathList.findClass()`的时候会优先获取`Element[]`数组中 最靠前的`Element`中的类**

那么 只需要Hook掉 这个`Element[] dexElements`,利用插件信息生成一个`Element` 并添加到这个数组.

