# 插件加载机制

[Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)

[ClassLoader原理学习.md](https://github.com/iwantthink/TODO/blob/master/AOP/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.md)

# 1. 简介

通常情况下,插件会以额外的文件 存在于assets目录 或者 从网络下载.**这里就涉及到了一个问题 如何将额外的class文件加载到内存中.例如我们启动一个Activity,之前我们已经解决了启动未在清单文件中声明的Activity,但这时这个Activity存在于插件中,Activity是否能正确加载?**

**本文基于Android27**
# 2. 启动插件中的Activity会遇到的问题

## 2.1 正常Activity类的加载逻辑
Activity类对象的具体创建在`ActivityThread.performLaunchActivity()`方法中:

	ContextImpl appContext = createBaseContextForActivity(r);
	Activity activity = null;
	try {
		java.lang.ClassLoader cl = appContext.getClassLoader();
		activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
		``省略代码``
	} catch (Exception e) {
		``省略代码```
	}
	// Instrumentation.newActivity()
    public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        return (Activity)cl.loadClass(className).newInstance();
    }


- Android通过`ClassLoader`将目标类加载到内存中,然后通过反射调用构造函数将该类创建出来

- Activity创建过程中使用的ClassLoader就是`PathClassLoader`

		//ContextImpl.getClassLoader()
	    @Override
	    public ClassLoader getClassLoader() {
	        return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
	    }
		//ClassLoader
	    @CallerSensitive
	    public static ClassLoader getSystemClassLoader() {
	        return SystemClassLoader.loader;
	    }
		//ClassLoader
	    static private class SystemClassLoader {
	        public static ClassLoader loader = ClassLoader.createSystemClassLoader();
	    }
		//ClassLoader.createSystemClassLoader()
	    private static ClassLoader createSystemClassLoader() {
	        String classPath = System.getProperty("java.class.path", ".");
	        String librarySearchPath = System.getProperty("java.library.path", "");
	        return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
	    }

- **Android系统使用PathClassLoader来加载系统类和应用程序的类，如果是加载应用程序类，则会加载`data/app/`目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载哪种类型的文件，最终都是加载dex文件**

## 2.2 插件遇到的问题

Android系统使用ClassLoader机制去加载类,在Activity类的加载过程之中,使用了`PathClassLoader`类加载器. **这个类加载器有一个特点就是只能加载已安装应用的dex或apk文件**,插件大多不符合这个条件(插件位置是任意的),因此正常情况下系统无法加载插件中的类,也没办法创建插件中的Activity对象

# 3. ClassLoader机制介绍

具体的去看[ClassLoader原理学习.md](https://github.com/iwantthink/TODO/blob/master/AOP/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/ClassLoader%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.md)

>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校检、转换解析和初始化的，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
与那些在编译时进行链连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以同代拓展的语言特性就是依赖运行期动态加载和动态链接这个特点实现的。例如，如果编写一个面相接口的应用程序，可以等到运行时在制定实际的实现类；用户可以通过Java与定义的和自定义的类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为代码的一部分，这种组装应用程序的方式目前已经广泛应用于Java程序之中。从最基础的Applet，JSP到复杂的OSGi技术，都使用了Java语言运行期类加载的特性。


Java类加载过程包括:加载,验证,准备,解析和初始化五个阶段,**加载阶段是最适合修改的地方**.加载阶段主要完成三件事:

1. 根据类的全限定名来获取定义此类的二进制字节流

2. 将这个字节流锁代表的静态存储结构转换为JVM方法区中的运行时数据结构

3. 在内存中生成一个代表这个类的`java.lang.Class`对象,作为方法区这个类的各种数据的访问入口

**Android中的ClassLoader:**

- **Android系统使用`PathClassLoader`来加载系统类和应用程序的类,其有一个限制:只能加载已安装应用的dex或apk文件.**

- **另外还提供了`DexClassLoader`,可以用来加载不能用`PathClassLoader`加载的类**


# 4. 如何加载插件?

## 4.1 解决思路

之前已经提到 插件的类无法被`PathClassLoader`加载,那么解决这个问题有俩个方式:

1. 全面接管系统的类加载过程

2. 单单告诉系统插件位置,让系统帮忙加载

- **这俩种方式都需要干预类加载这个过程**

## 4.2 Activity加载所使用的ClassLoader

1. `ActivityThread.performLaunchActivity()`

		ContextImpl appContext = createBaseContextForActivity(r);
		java.lang.ClassLoader cl = appContext.getClassLoader();

	- 具体的类加载器 是交给`ContextImpl`来实现的

2. ContextImpl.getClassLoader()

	    @Override
	    public ClassLoader getClassLoader() {
	        return mClassLoader != null ? mClassLoader : (mPackageInfo != null ? mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader());
	    }

3. ClassLoader

	    @CallerSensitive
	    public static ClassLoader getSystemClassLoader() {
	        return SystemClassLoader.loader;
	    }

4. ClassLoader.createSystemClassLoader()

	    static private class SystemClassLoader {
	        public static ClassLoader loader = ClassLoader.createSystemClassLoader();
	    }

5. ClassLoader.createSystemClassLoader()
	    private static ClassLoader createSystemClassLoader() {
	        String classPath = System.getProperty("java.class.path", ".");
	        String librarySearchPath = System.getProperty("java.library.path", "");
	        return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance());
	    }