# Binder
[为什么 Android 要采用 Binder 作为 IPC 机制？](https://www.zhihu.com/question/39440766)

[Binder学习指南-weishu](http://weishu.me/2016/01/12/binder-index-for-newer/)

**学习Binder路线：**

1. 先学会熟练使用AIDL进行跨进程通信（简单来说就是远程Service）
2. 看完本文
3. 看Android文档，Parcel, IBinder, Binder等涉及到跨进程通信的类
4. 不依赖AIDL工具，手写远程Service完成跨进程通信
5. 看《Binder设计与实现》
6. 看老罗的博客或者书（书结构更清晰）
7. 再看《Binder设计与实现》
8. 学习Linux系统相关知识；自己看源码。

# 1. IPC介绍以及Binder介绍

Android系统基于Linux内核，存在**进程隔离**，即对每个进程来说，并不知道其他进程的存在，**因此一个进程需要通过某种机制和另外一个进程进行进程通信**

- 进程隔离是为保护操作系统中进程互不干扰而设计的一组不同硬件和软件的技术。这个技术是为了避免进程A写入进程B的情况发生。 进程的隔离实现，使用了虚拟地址空间。进程A的虚拟地址和进程B的虚拟地址不同，这样就防止进程A将数据信息写入进程B

**Linux用户空间/内核空间之间的访问**

- Linux Kernel是操作系统的核心，独立于普通的应用程序，可以访问受保护的内存空间，也有访问硬件设备的所有权限

	对于Kernel存在一个保护机制，这个保护机制用来区分Kernel和上层的应用程序(称之为Kernel Space/User Space),即区分资源访问的权限，只能访问被许可的资源

	虽然从逻辑上抽离出**用户空间 和 内核空间**。但是还是存在一些用户空间会需要访问内核的资源(例如：应用程序访问文件，网络)

		Kernel space can be accessed by user processes only through the use of system calls.

	对此，Linux提供了**系统调用**这种方式，来使得用户空间访问内核空间。通过这个统一的入口接口，所有的资源访问都是在内核的控制下执行，以免用户对系统资源的越权访问，从而保障安全和稳定。

	当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于**内核运行态（或简称为内核态）此时处理器处于特权级最高的（0级）内核代码中执行**。当进程在执行用户自己的代码时，则称其处于**用户运行态（用户态）**。**即此时处理器在特权级最低的（3级）用户代码中运行**。处理器在特权等级高的时候才能执行那些特权CPU指令。

**用户空间之间的访问：**

- 通过系统调用，用户空间可以访问内核空间。那么一个用户空间想要访问另外一个用户空间 可以让操作系统内核添加支持。传统的Linux通信机制，例如Socket，管道等都是内核支持的。

	Binder并不是Linux内核的一部分，它是通过**Linux的动态可加载内核模块(Loadable Kernel Module,LKM)**机制解决的通信。该模块是具有独立功能的程序，可以被单独编译但是不能单独运行。它在运行时被链接到内核作为内核的一部分在内核空间运行。

	也就是说：**Android系统通过添加一个内核模块运行在内核空间，而用户进程通过这个模块作为桥梁 来完成通信。在Adnroid系统中，这个运行在内核空间，负责各个用户进程通信的内核模块叫做Binder驱动**

	- 驱动程序一般指的是设备驱动程序（Device Driver），是一种可以使计算机和设备通信的特殊程序。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作；

		**驱动就是操作硬件的接口，为了支持Bindler通信过程，Binder使用了一种“硬件”，因此这个模块被称之为驱动**

## 1.1 为什么使用Binder？

Android使用的Linux内核拥有着非常多的跨进程通信机制，比如管道，System V，Socket等；为什么还需要单独搞一个Binder出来呢？**主要有两点，性能和安全**。在移动设备上，广泛地使用跨进程通信肯定对通信机制本身提出了严格的要求；Binder相对出传统的Socket方式，更加高效；另外，传统的进程通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设；比如Socket通信ip地址是客户端手动填入的，都可以进行伪造；而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。这个也是Android权限模型的基础。

## 1.2 Binder通信模型

跨进程通信通常分为CS，即Server进程和Client进程，由于进程隔离的存在，它们之间无法直接通信

**日常生活中通信：**

- 假设A.B进行通信(A是Client,B是Server)，通信的媒介是打电话,A要打电话给B，那么必须知道B的电话，电话从通信录中得知

	必须先查阅通信录，拿到B的电话，A才能和B进行通信。另外这里还需要基站的支持

**Bindler通信：**

- 俩个运行在用户空间的进程要进行通信，需要借助内核的帮助(实际上是需要可加载内核模块)，这个运行在内核中的程序叫做**Binder驱动**，它的功能类似基站，另外打电话通信中的通信录对应Binder通信中的`ServiceManager`

	![](http://7xp3xc.com1.z0.glb.clouddn.com/binder-model.png)

**整体流程如下：**

1. ServiceManager建立(即 通信录建立)，首先有一个进程向驱动提出申请为SM。驱动同意之后，SM进程负责管理Service(这里管理的是Service而不是Server，因为CS是可以反过来的，Server也有可能会向Client进行通信。只不过这个时候 代表Client的Service并没有在SM中注册)

2. 各个Server向SM注册：每个Server端进程启动之后，通过SM进行注册，例如我是AMS,我的地址是0x123，依次类推。这样SM就能建立一个对应关系，对应着Server的名字和地址

3. Clinet想要和Server通信，首先通过这个SM拿到Server的地址，然后根据这个地址进行通信

- 在这个流程中，无论是client和Server的通信 还是client和sm的通信 都会通过 Binder驱动

- 以上就是整个Binder通信的基本模型，需要注意的是SM整个系统中只有一份，驱动也只有一个

## 1.3 Binder机制跨进程原理

Binder通信中的四个角色：client,server,sm,driver。那么具体client如何与server完成通信的？

**普通的进程间通信的原理：**

- 内核可以访问A和B的所有数据；所以，最简单的方式是通过内核做中转；假设进程A要给进程B发送数据，那么就先把A的数据copy到内核空间，然后把内核空间对应的数据copy到B就完成了；用户空间要操作内核空间，需要通过系统调用；刚好，这里就有两个系统调用：`copy_from_user, copy_to_user`。

**Bindler机制：**

Binder机制并不是通过以上方式实现的，**通信是一个广泛的概念，只要一个进程能调用另外一个进程里某个对象的方法，那么具体要完成什么通信内容就很容易**

![](http://7sbqce.com1.z0.glb.clouddn.com/2016binder-procedure.png)

1. Server进程向SM注册，告诉SM自己的名字，有什么能力。即Server告诉SM自己叫ASM，自己有个object对象，可以执行add操作。于是SM建立了一张表，然后保存了这些信息

2. client向SM查询：我需要联系 名字=ASM 的进程中的object对象。**这时候，进程之间通信的数据都会经过运行在内核空间里面的Binder驱动，Binder驱动在数据流过的时候做了一点处理，它并不会直接给client返回一个真正的object对象，而是返回一个object的代理对象(objectProxy),这个objectProxy也有一个add方法，这个add方法所做的事情只是将参数进行包装然后交给binder驱动(简化了SM流程，见下文)**

3. client并不知道返回的对象不是真正的对象，其实它也没有必要知道，因为它只需要一个结果。那么client拿到了这个代理对象并调用对应的方法之后，这个方法包装了参数 并交给驱动

4. 驱动在收到包装后的数据，知道是objectProxy 传回来的数据，然后这个objectProxy对应的是object。于是binder驱动通知server进程，调用server进程的object的add方法，在server进程处理完之后，返回处理结果给binder驱动，驱动再把这个结果返回给client。至此 整个流程结束。

- **由于驱动返回的objectProxy与Server进程中的十分相似，给人的感觉像是Server进程中的object对象传递到了Client进程。因此 称Binder对象是可以进行跨进程传递的对象**

	但是实际上Binder跨进程传输时并不是真的把一个对象传输到了另外一个进程