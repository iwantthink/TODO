# 视图的创建过程

[Android开发艺术探索]()

[深入理解Android 卷III]()

# 1. 简介

Android中所有的视图都是通过`Window`来呈现的,不管是`Activity`,`Dialog`,`Toast`,它们的视图都是附加在`Window`上,**因此`Window`是`View`的直接管理者**

# 1. Window创建过程

`ActivityThread`的`performLaunchActivity()`方法在创建`Activity`时,会调用`Activity`的`attach()`,`Window`就在这时候被创建

1. `Activity`的启动过程中,与`Window`的创建相关的逻辑在调用到`Activity.attach()`方法中

2. 在`Activity.attach()`方法中,系统会创建`Activity`所属的`Window`对象并为其设置回调接口,**`Window`对象的创建是直接创建一个`PhoneWindow`**

	由于`Activity`实现了`Window`的`Callback`接口,因此当`Window`接收到外接的状态改变时就会回调`Activity`的方法


## 1.1 Activity.attach()

	final void attach(Context context, ActivityThread aThread,
	            Instrumentation instr, IBinder token, int ident,
	            Application application, Intent intent, ActivityInfo info,
	            CharSequence title, Activity parent, String id,
	            NonConfigurationInstances lastNonConfigurationInstances,
	            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
	            Window window) {
	        attachBaseContext(context);
	        mFragments.attachHost(null /*parent*/);
			//创建了Window
	        mWindow = new PhoneWindow(this, window);
	        ...
	        //具体的实现在PhoneWindow的父类,Window中
	        mWindow.setWindowManager(
	                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
	                mToken, mComponent.flattenToString(),
	                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
	      ...

- `Context.WINDOW_SERVICE` = `"window"`;


## 1.2 Window.setWindowManager()

	public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
	        boolean hardwareAccelerated) {
	    mAppToken = appToken;
	    mAppName = appName;
	    mHardwareAccelerated = hardwareAccelerated
	            || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);
	    if (wm == null) {
	        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
	    }
	    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
	}

- 如果传入的`WindowManager`为空,则会通过`ContextImpl`去获取.实际上在`attach()`方法中,也是同样的获取.**实际上获取到的WM是`WindowManagerImpl`**,这一点通过继续阅读代码(1.2.1) 可以得出



### 1.2.1 WindowManager的创建

	context.getSystemService(Context.WINDOW_SERVICE)

- 这里的`context`就是`ContextImpl`,从`ActivityThread.performLaunchActivity()`方法中可以得知

### 1.2.2 ContextImpl.getSystemService()
	
	@Override
	public Object getSystemService(String name) {
	    return SystemServiceRegistry.getSystemService(this, name);
	}

### 1.2.3 SystemServiceRegistry.getSystemService()

    public static Object getSystemService(ContextImpl ctx, String name) {
        ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);
        return fetcher != null ? fetcher.getService(ctx) : null;
    }

- `SystemServiceRegistry`会在其静态代码块中调用`registerService()`方法,将一些Manager的关系添加到`SYSTEM_SERVICE_NAMES`和`SYSTEM_SERVICE_FETCHERS`

- `SYSTEM_SERVICE_FETCHERS`

	`SYSTEM_SERVICE_FETCHERS`是一个HashMap类型的数据，key-value关系是 `serviceName-serviceFetcher`

- **已知此处的`ServiceFetcher`是`CachedServiceFetcher`类型**

### 1.2.4 SystemServiceRegistry 静态代码块

	final class SystemServiceRegistry {
	...
	 private SystemServiceRegistry() { }
	 static {
	 ...
	   registerService(Context.WINDOW_SERVICE, WindowManager.class,
	                new CachedServiceFetcher<WindowManager>() {
	            @Override
	            public WindowManager createService(ContextImpl ctx) {
	                return new WindowManagerImpl(ctx);
	            }});
	...
	 }
	}

    private static <T> void registerService(String serviceName, Class<T> serviceClass,
            ServiceFetcher<T> serviceFetcher) {
        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);
        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);
    }

### 1.2.5 CachedServiceFetcher.getService(ctx)


		static abstract class CachedServiceFetcher<T> implements ServiceFetcher<T> {
        private final int mCacheIndex;

        public CachedServiceFetcher() {
            mCacheIndex = sServiceCacheSize++;
        }

        @Override
        @SuppressWarnings("unchecked")
        public final T getService(ContextImpl ctx) {
            final Object[] cache = ctx.mServiceCache;
            synchronized (cache) {
                // Fetch or create the service.
                Object service = cache[mCacheIndex];
                if (service == null) {
                    try {
                        service = createService(ctx);
                        cache[mCacheIndex] = service;
                    } catch (ServiceNotFoundException e) {
                        onServiceNotFound(e);
                    }
                }
                return (T)service;
            }
        }

        public abstract T createService(ContextImpl ctx) throws ServiceNotFoundException;
    }

- 看到这里,可以得出一个结论

	**`mContext.getSystemService(Context.WINDOW_SERVICE)`方法获取到的`WindowManager`实际类型就是`WindowManagerImpl`**



## 1.3 WindowManagerImpl.createLocalWindowManager()

	public WindowManagerImpl createLocalWindowManager(Window parentWindow) {
	       return new WindowManagerImpl(mContext, parentWindow);
	   }

- `createLocalWindowManagerImpl()`方法同样是创建了`WindowManagerImpl`,但是这一次同时将`Window`作为参数传入,**这样`WindowManagerImpl`就持有了`Window`,就可以对`Window`进行操作**.例如添加View


# 2. PhoneWindow的介绍

`PhoneWindow`继承自`conm.view.Window`,从更高级别的层次上描述了一个窗口的特性

- 当开发者通过**`WindowManager`,`LayoutParams`以及控件树** 创建一个窗口时,需要手动初始化`LayoutParams`以及自行构建控件树 . 

	如今的窗口中的内容往往都有不成文的规范,比如在指定位置有标题栏,动作栏,图标等,手动创建符合这些规范的控件树十分麻烦

	为此Android提供了`com.view.Window`类,用来提供一个模板窗口类来创建窗口

## 2.1 Window的核心功能

Window类中有三个最核心的组件,其核心功能就是根据这三个组件来实现

1. `WindowManager.LayoutParams`

2. 一颗控件树

3. `Window.Callback`

**`Window`类实现的功能总结:**

- `Window`类是一个模板,简化了符合一定规范的控件树的创建过程,使得使用者仅需少量工作就能将自己要展示的内容嵌套在一个 符合标准的窗口外观下,而不需要关心这一窗口外观的具体构成

	另外`Window`类还是一个抽象类,因此使用不同的`Window`类实现可以在不修改应用程序原有逻辑的情况下提供完全不同的窗口外观

- **目前Android 中使用`PhoneWindow`作为`Window`的实现类,后者提供了用于修改`LayoutParams`的接口等通用功能的实现,前者负责具体的外观模板**
	

### 2.1.1 WindowManager.LayoutParams

`Window`类提供了一系列set方法用于设置`LayoutParams`属性,其优势在于它可以根据**用例**初始化`LayoutParams`中的属性,例如窗口令牌,窗口名称以及FLAG等


### 2.1.2 控件树

`Window`提供了许多 控件树模板,这些模板可以为窗口提供形式多样但风格统一的展示方式以及辅助功能,例如标题栏,图标,顶部进度条,动作栏等,设置它还未使用者提供了选项菜单的实现

使用者仅需将显示其所关心内容的控件树交给它,它就会将其嵌套在模板的合适位置 . 这一模板就是最终显示时的窗口外观(外观模板)

- `Window`类提供了接口用于模板选择,指定期望显示内容以及修改模板的属性(如标题,图标,进度条进度等)

### 2.1.3 Window.Callback

`Window.Callback`是一个接口,`Window`的使用者可以实现这个接口并注册到`Window`中,这样当窗口发生变化时就可以得到通知

- **可以通过这一接口得到 输入事件,窗口属性变更,菜单的弹出/选择等**


## 2.2 PhoneWindow选择窗口外观与设置显示内容






# 3. Activity视图的创建与关联

前面的小节中,仅仅只是创建了`PhoneWindow`,`WindowManager`, Activity的视图并没有被创建,接下来 要介绍视图的创建与关联

1. `Activity`的启动过程中,在执行完`activity.attach()`之后,会通过`Instrumentation.callActivityOnCreate()`调用`Activity`的`onCreate()`. 

	**`Activity`的视图是由`setContentView()`方法提供,并且它是在`onCreate()`方法中被调用**

2. 查看`Activity`的`setContentView()`

	    public void setContentView(@LayoutRes int layoutResID) {
	        getWindow().setContentView(layoutResID);
	        initWindowDecorActionBar();
	    }

	- 通过代码可以知道,`Activity`将具体实现交给`Window`来实现

	- `getWindow()`方法就是获取在`attach()`方法中创建的那个`PhoneWindow`

## 2.1 PhoneWindow.setContentView()

	   @Override
	    public void setContentView(int layoutResID) {
	        //
	        if (mContentParent == null) {
	            installDecor();
	        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
				//如果没有5.0转场动画,则remove掉之前所有添加的view
	            mContentParent.removeAllViews();
	        }
			// 5.0 转场动画
	        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
	            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
	                    getContext());
	            transitionTo(newScene);
	        } else {
	            mLayoutInflater.inflate(layoutResID, mContentParent);
	        }
			// 通知Activity 视图发生改变
	        mContentParent.requestApplyInsets();
	        final Callback cb = getCallback();
	        if (cb != null && !isDestroyed()) {
	            cb.onContentChanged();
	        }
	        mContentParentExplicitlySet = true;
	    }

- `mContentParent`就是id为`ID_ANDROID_CONTENT`的FrameLayout,实际上`setContentView`就是为`mContentParent`添加一个子类.

- `installDecor()`方法主要完成了俩个事情

	1. 创建`DecorView`,通过配置给`DecorView`进行设置

	2. 给`mContentParent`赋值

- `mLayoutInflator.inflate()`主要的作用是:

	**给mContentParent添加子view.换而言之就是将 `layoutResID` 解析成view 并添加到 mContentParent**

- 在创建好视图之后,会回调`Activity`的`onContentChanged()`方法通知`Activity`视图已经发生了变化

- **一个Window对象对应着一个View(DecorView),`ViewRootImpl`就是对这个`DecorView`进行操作**


### 2.1.1 PhoneWindow.installDecor()

    private void installDecor() {
        mForceDecorInstall = false;
        if (mDecor == null) {
			//生成DecorView,就是new 了一个DecorView(FrameLayout的子类)
            mDecor = generateDecor(-1);
			.......
        } else {
			// 将DecorView和Window进行关联
            mDecor.setWindow(this);
        }
       if (mContentParent == null) {
			// 根据DecorView 生成 mContentParent
            mContentParent = generateLayout(mDecor);
			..............
		}

### 2.1.2 PHoneWindow.generateLayout()

    protected ViewGroup generateLayout(DecorView decor) {
        // Apply data from current theme.
		//获得Window的样式
        TypedArray a = getWindowStyle();
		//省略代码
		//通过WindowStyle中设置的各种属性,对Window
		//进行requestFeature或者setFlags

        // Inflate the window decor.
		//
        int layoutResource;
        int features = getLocalFeatures();
		//主要功能就是根据不同的配置 给DecorView添加不同的布局文件
		//即 给DecorView添加不同的子节点
        // System.out.println("Features: 0x" + Integer.toHexString(features));
        if ((features & (1 << FEATURE_SWIPE_TO_DISMISS)) != 0) {
            layoutResource = R.layout.screen_swipe_dismiss;
            setCloseOnSwipeEnabled(true);
        } else if ((features & ((1 << FEATURE_LEFT_ICON) | (1 << FEATURE_RIGHT_ICON))) != 0) {
            if (mIsFloating) {
                TypedValue res = new TypedValue();
                getContext().getTheme().resolveAttribute(
                        R.attr.dialogTitleIconsDecorLayout, res, true);
                layoutResource = res.resourceId;
            } else {
                layoutResource = R.layout.screen_title_icons;
            }
            // XXX Remove this once action bar supports these features.
            removeFeature(FEATURE_ACTION_BAR);
            // System.out.println("Title Icons!");
        } 
		// 省略添加的代码
        mDecor.startChanging();
		//下面的方法是将找到的不同的布局文件,添加给DecorView
		//这里也说明了，我们经常写的requestWindowFeature(Window.FEATURE_NO_TITLE)代码为什么一定放在setContentView之前。
		//因为系统会根据配置找不同的布局文件，而一旦添加了布局文件，就没有办法再移除title了。因此会抛出异常
        mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);
		//找到 contentParent,其实findViewById内部调用的是DecorView.findViewByID
        ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
      	//省略代码
        mDecor.finishChanging();
        return contentParent;
    }

- `generateLayout()`主要功能就是:

	1. **通过`findViewByID()`方法找到`DecorView`中id为`ID_ANDROID_CONTENT`的`view`.并赋值给`mContentParent`**

	2. 根据不同的配置给`DecorView`添加不同的`layoutResource`布局文件

# 3. Activity视图真正可见的时候

**截止到回调为止,DecorView创建并初始化完毕,Activity的布局文件也被添加到了`DecorView`的子布局`ID_ANDROID_CONTENT`中(即mContentParent所代表的view),但是这个时候,`DecorView`仍未被`WindowManager`正式添加到`Window`中**

`Window`更多表示的是一种抽象的功能集合,虽然已经在`Activity.attach()`方法中被创建,但是这个时候由于`DecorView`并没有被`WindowManager`识别,所以这个时候的`Window`无法提供具体的功能,**因为它还无法接收外接的输入信息**

在`ActivityThread`的`handleResumeActivity()`方法中,首先会调用`Activity`的`onResume()`方法,然后会调用`Activity`的`makeVisible()`,正是这个方法中,`DecorView`真正完成了添加和显示这俩个过程,直到这时候`Activity`的视图才能被用户看到

