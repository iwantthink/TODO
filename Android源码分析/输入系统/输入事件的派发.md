# 输入事件的派发

[深入理解Android 卷iii PDF版]()

# 1. 简介

控件树中的输入事件派发是由`ViewRootImpl`为起点,沿着控件树逐层传递给目标控件,最终再回到`ViewRootImpl`的一个环形过程

事件派发的过程发生在创建`ViewRootImpl`的主线程中,但却独立与`ViewRootImpl.performTraversals()`之外,即输入事件的派发并不依赖于`ViewRootImpl`的`心跳`作为动力. **它的动力来源于`InputEventReceiver`的`Looper`,当一个输入事件被派发给`ViewRootImpl`所在的窗口时,`Looper`会被唤醒并触发`InputEventReceiver.onInputEvent()`回调,控件树的输入事件派发起始于这一回调.**


# 2. 触摸模式和焦点

Android同时支持按键与触摸俩种操作方式,并且可以在俩者之间自由切换

可以获取焦点的控件分为俩类:

1. 任何情况下都可以获取焦点的控件 ,如文本输入框
2. 仅在键盘操作时可以获取焦点的控件,如菜单项,按钮等

**触摸模式(TouchMode)**是为了管理俩者的差异而引入的概念,Android通过进入或退出触摸模式实现二者无缝切换 . 

- 在非触摸模式下:

	文本框,按钮,菜单项等都可以获取焦点,并且可以通过方向键使得焦点在这些控件之间切换

- 在触摸模式下:

	某些控件如菜单项,按钮将不再可以保持或获取焦点,而文本框则仍然可以保持或获取焦点


**触摸模式**是一个系统级的概念,就是说会对所有窗口产生影响.系统是否处于触摸模式取决WMS中的一个成员变量`mInTouchMode`

    /**
     * Whether the UI is currently running in touch mode (not showing
     * navigational focus because the user is directly pressing the screen).
     */
    boolean mInTouchMode;

- 退出触摸模式的操作有  

	1. 按下方向键
	2. 通过键盘按下字母键
	3. 执行了`View.requestFocusFromTouch()`

- 进入触摸模式的操作:

	1. 用户在窗口上进行了点击操作 . 窗口的`ViewRootImpl`会识别上述操作,然后通过WMS的接口`setInTouchMode()`设置`mInTouchMode`的值

	**只有拥有`ViewRootImpl`的窗口才能影响触摸模式,或对触摸模式产生响应**

系统进入或退出触摸模式对控件系统的最主要的影响是 其对焦点的选择策略



# 3 控件焦点

控件的焦点影响按键事件的派发,还影响了控件的表现形式(拥有焦点的控件往往会高亮显示以区分)

## 3.1 获取焦点的条件

控件获取焦点的方式很多,例如从控件树中按照一定策略查找到某个控件并使其获得焦点,或用户通过方向键选择某个控件使其获得焦点 .**而最基本的方式是通过`View.requestFocus()`**


`View.requestFocus()`的实现有俩种,即`View`和`ViewGroup`是不同的

- 当调用的控件为View时,表示期望此View能够获取焦点

- 当调用的控件为ViewGroup时,则会根据一定的焦点选择策略选择一个子控件或者ViewGroup本身作为焦点


**当控件树被添加到`ViewRootImpl`之后,也会调用`ViewRootImpl.requestFocus()`设置初始的焦点**

## 3.2 View的requestFocus()

    public final boolean requestFocus() {
        return requestFocus(View.FOCUS_DOWN);
    }

- `View.FOCUS_DOWN`表示焦点的寻找方向. 当本控件是一个`ViewGroup`时将会从左上角开始沿着这个方向查找可以获取焦点的子控件,由于当前分析的是控件为View的情况,所以该参数无效


    public final boolean requestFocus(int direction) {
        return requestFocus(direction, null);
    }

- `Rect`参数表示上一个焦点控件的区域 . 表示从哪个位置开始沿着`direction`所指定的方向查找焦点控件.仅当控件是`ViewGroup`时有意义


    public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
        return requestFocusNoSearch(direction, previouslyFocusedRect);
    }

- 这个俩个参数的重载方法便是`View`和`ViewGroup`对焦点控件查找的分界点

	在`View`类型的控件中,直接调用了`View.requestFocusNoSearch()`,代表的含义就是无需查找,直接使本控件获取焦点


    private boolean requestFocusNoSearch(int direction, Rect previouslyFocusedRect) {
        // 首先必须是Focusable,另外不可见的控件也不能获取焦点
		// 可以通过View.setFocusable()进行设置
        if ((mViewFlags & FOCUSABLE) != FOCUSABLE
                || (mViewFlags & VISIBILITY_MASK) != VISIBLE) {
            return false;
        }

        // 如果系统目前处于触摸模式,则要求此控件必须可以在触摸模式下可以拥有焦点
        if (isInTouchMode() &&
            (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags & FOCUSABLE_IN_TOUCH_MODE))) {
               return false;
        }

        // need to not have any parents blocking us
		// 判断是否存在任意父控件的DescendantFocusability取值为FOCUS_BLOCK_DESCENDANTS,意义为阻止此控件获取焦点
        if (hasAncestorThatBlocksDescendantFocus()) {
            return false;
        }

		//通过此方法使得控件获取焦点
        handleFocusGainInternal(direction, previouslyFocusedRect);
        return true;
    }

**控件能否获取焦点有一下俩个要求:**

1. 并不是所有的控件都能够获取焦点

	控件系统通过`View.setFocusable()`设置控件能否获取焦点. 该方法会将`NOT_FOCUSABLE`或`FOCUSABLE`标记加入`View.mViewFlags`成员中

	**但是当控件持有`FOCUSABLE`标记时,也不一定能够获取焦点**. 控件系统通过`View.setFocusableInTouchMode()`区分这类控件,该方法会将`FOCUSABLE_IN_TOUCH_MODE`标记加入`View.mViewFlags`中

	**当控件处于触摸模式时,仅当拥有`FOCUSABLE_IN_TOUCH_MODE`标记的控件才能获取焦点**

2. 控件能否获取焦点还取决于其父控件的特性`DescendantFocusability`,这一特性描述了子控件与父控件之间的焦点获取策略

	`DescendantFocusability`存在三种取值,例如在`FOCUS_BLOCK_DESCENDANTS`时 父控件会阻止子控件获取焦点


**因此控件是否能够获取焦点的策略如下:**

1. 当`View.mViewFlags`存在`NOT_FOCUSABLE`标记时,无法获取焦点

2. 当其父控件的`DescendantFocusability`取值为`FOCUS_BLOCK_DESCENDANTS`时,无法获取焦点

3. 当`View.mViewFlags`存在`FOCUSABLE`标记时,有俩种情况

	- 位于非触摸模式,控件可以获取焦点
	- 位于触摸模式,控件的`View.mViewFlags`必须持有`FOCUSABLE_IN_TOUCH_MODE`标记才可以获取焦点


### 3.2.1 获取焦点!

`View.handleFocusGainInternal()`

    void handleFocusGainInternal(@FocusRealDirection int direction, Rect previouslyFocusedRect) {

        if ((mPrivateFlags & PFLAG_FOCUSED) == 0) {
			//将PFLAG_FOCUSED加入mPrivateFlags中
			// 这便表示此控件已经拥有焦点!
            mPrivateFlags |= PFLAG_FOCUSED;

            View oldFocus = (mAttachInfo != null) ? getRootView().findFocus() : null;

			//将焦点变换通知其父控件
			// 这一操作主要是为了保证控件树中仅有一个控件拥有焦点!!!
			// 并且在ViewRootImpl中触发一次遍历从而进行重绘
            if (mParent != null) {
                mParent.requestChildFocus(this, this);
                updateFocusedInCluster(oldFocus, direction);
            }

			
            if (mAttachInfo != null) {
                mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);
            }
			//通知对此控件焦点变换感兴趣的监听者
            onFocusChanged(true, direction, previouslyFocusedRect);
			//更新控件的Drawable状态.是的控件在绘制中出现高亮显示
            refreshDrawableState();
        }
    }

- `PFLAG_FOCUSED`是一个控件是否拥有焦点的最直接体现,但这一标记仅体现了焦点在个体级别上的特性,而`mParent.requestChildFocus()`则体现了焦点在控件树级别的特性

### 3.2.2 控件树中的焦点体系

`mParent.requestChildFocus()`方法是定义在`ViewParent`接口中的方法,其实现者为`ViewGroup`和`ViewRootImpl`.

- `ViewGroup`实现的目的之一就是将焦点从上一个焦点控件手中夺走, 即将`PFLAG_FOCUSED`标记从控件的`mPrivateFlags`中移除

- 另外一个目的是 将这一操作继续向控件树的根部进行回溯,直到`ViewRootImpl`,`ViewRootImpl`的`requestChildFocus()`方法会将焦点控件保存起来备用,并引发一次遍历

`[ViewGroup.requestChildFocus()]`

    @Override
    public void requestChildFocus(View child, View focused) {

        if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
            return;
        }

        // 如果上一个焦点控件就是这个ViewGroup,则通过`View.unFocus()`将`PFLAG_FOCUSED`标记移除,以释放焦点
        super.unFocus(focused);

		// mFocused代表拥有焦点控件的父控件
		// child 在View调用requestChildFocus()时 为 View本身
		//  	 在ViewGroup调用requestChildFocus()时为 ViewGroup本身
		// 第一次调用时 mFocused 为空,肯定不等于View,那么mFocused直接被赋值为View本身
        if (mFocused != child) {
	        // 如果上一个焦点控件 是这个控件树中的子控件,即mFocused 不为空
			// 则调用 该子控件的unFocus()
            if (mFocused != null) {
                mFocused.unFocus(focused);
            }
			//新焦点体系的建立
			// 设置mFocused为child
			// child参数并不是实际拥有焦点的控件,而是此ViewGroup的直接子控件,同时它是实际拥有焦点的控件的父控件
            mFocused = child;
        }
			
		// 将这一操作继续向控件树的根部回溯
		// 此时 child参数是 此VIewGroup,而不是实际拥有焦点的focused
        if (mParent != null) {
            mParent.requestChildFocus(this, focused);
        }
    }

- 如果是`View`调用了`mParent.requestChildFocus()`,则在`ViewGroup.requestChildFocus()`方法中,`mFocused`并不会被赋值

- `ViewGroup.requestChildFocus()`方法包含了新的焦点体系的建立过程,以及旧的焦点体系的销毁过程

	新的焦点体系建立通过`ViewGroup.requestChildFocus()`方法的回溯过程中进行`mFocused=child`完成,这实际上是建立了一个单向链表,通过`mFocused`可以从根控件开始沿着这一单向链表找到实际拥有焦点的控件

	旧的焦点体系摧毁是通过在回溯过程调用`mFocused.unFocus`完成

- `ViewGroup.unFocus()`

		@Override
	    void unFocus(View focused) {
			// 如果mFocused为空,则表示此ViewGroup位于mFocused单向链表的尾端
			// 即此ViewGroup是焦点的实际拥有者,因此调用View.unFocus()使此ViewGroup放弃焦点
	        if (mFocused == null) {
				//调用View.unFocus()
	            super.unFocus(focused);
	        } else {
				//传递给链表的下一个控件
	            mFocused.unFocus(focused);
				//同时将当前的mFocused 置空
	            mFocused = null;
	        }
	    }

- `View.unFocus()`

	    void clearFocusInternal(View focused, boolean propagate, boolean refocus) {
	        if ((mPrivateFlags & PFLAG_FOCUSED) != 0) {
	            mPrivateFlags &= ~PFLAG_FOCUSED;
	
	            if (propagate && mParent != null) {
	                mParent.clearChildFocus(this);
	            }
	
	            onFocusChanged(false, 0, null);
	            refreshDrawableState();
	
	            if (propagate && (!refocus || !rootViewRequestFocus())) {
	                notifyGlobalFocusCleared(this);
	            }
	        }
	    }

### 3.2.3 View类型控件获取焦点流程(View.requestChildFocus())

![](http://ww1.sinaimg.cn/large/6ab93b35gy1fx7ga3a05oj20n60bhwh3.jpg)

1. 当`View2-1-1`通过`View.requestFocus()`尝试获取焦点时,首先会将`PFLAG_FOCUSED`标记加入其成员`mPrivateFlags`中,以声明其拥有焦点

2. 然后调用`ViewGrou2-1`的`requestChildFocus()`,此时`2-1`会通过`unFocus()`销毁旧的焦点体系,但是由于其`mFocused`为null,它无法进行销毁旧的焦点体系.同时它将`mFocused`设置为`View2-1-1`,并将调用`ViewGroup2`的`requestChildFocus()`

3. `ViewGroup2`的`mFocused`指向了`View2-2`,于是调用了`ViewGroup2-2`的`unFocus()`进行旧的焦点体系的销毁. 

4. `ViewGroup2-2`的`unFocus()`将此操作传递给`View2-2-2`的`unFocus()`以移除`View2-2-2`的`PFLAG_FOCUSED`标记,并将其`mFocused`置空

5. `ViewGroup2-2`销毁了旧的焦点体系之后,回到`ViewGroup2`将`mFocused`置为`View2-1-1`


- `View`类有俩个查询控件焦点状态的方法,

	1. `isFocused()`:是否拥有`PFLAG_FOCUSED`,控件直接拥有焦点

	2. `hasFocuse()`:是否拥有`PFLAG_FOCUSED`或者`mFocused`不为空,即理解为 焦点被自身拥有或者被其子类拥有


## 3.3 ViewGroup的requestFocus()

已知`ViewGroup`会重写`requestFocus(int,Rect)`,拥有其自己的获取焦点的逻辑

    public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
	
		// 获取ViewGroup的 DescendantFocusability 特性的取值
        int descendantFocusability = getDescendantFocusability();

        switch (descendantFocusability) {
            case FOCUS_BLOCK_DESCENDANTS:
				// ViewGroup 将会阻止所有子控件获取焦点,于是调用View.requestFocus()尝试自己获取焦点
                return super.requestFocus(direction, previouslyFocusedRect);
            case FOCUS_BEFORE_DESCENDANTS: {
				//ViewGroup 将有优先于子控件获取焦点的权利
				// 首先调用View.requestFocus()尝试自己获取焦点,如果自己不满足获取焦点的条件,那么会调用onRequestFocusInDescendants()将获取焦点的请求转发给子控件
                final boolean took = super.requestFocus(direction, previouslyFocusedRect);
                return took ? took : onRequestFocusInDescendants(direction, previouslyFocusedRect);
            }
            case FOCUS_AFTER_DESCENDANTS: {
				// 子控件有优于ViewGroup获取焦点的权利
				// 首先调用onRequestFocusInDescendants()尝试让子控件获取焦点.倘若子控件无法获取焦点,则ViewGroup再尝试自己获取焦点
                final boolean took = onRequestFocusInDescendants(direction, previouslyFocusedRect);
                return took ? took : super.requestFocus(direction, previouslyFocusedRect);
            }
            default:
                throw new IllegalStateException(../...);
        }
    }

- `ViewGroup.requestFocus()`方法是会根据`DescendantFocusability`特性来决定焦点的获取逻辑

	开发者可以通过`ViewGroup.setDescendantFocusability()`方法修改该值

### 3.3.1 ViewGroup.onRequestFocusInDescendants()

    protected boolean onRequestFocusInDescendants(int direction,
            Rect previouslyFocusedRect) {
        int index;
        int increment;
        int end;
        int count = mChildrenCount;
		// 判断方向,决定初始值
        if ((direction & FOCUS_FORWARD) != 0) {
            index = 0;
            increment = 1;
            end = count;
        } else {
            index = count - 1;
            increment = -1;
            end = -1;
        }
		
        final View[] children = mChildren;
        for (int i = index; i != end; i += increment) {
            View child = children[i];
			//子控件必须是可见的
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
				// 调用子控件去获取焦点,如果子控件可以获取到焦点,那么直接停止查找
                if (child.requestFocus(direction, previouslyFocusedRect)) {
                    return true;
                }
            }
        }
        return false;
    }

- 此方法的目的是按照`direction`参数所描述的方向,在子控件列表中依次尝试使其获取焦点.

	**这里的`direction`并不是指代控件在屏幕上的位置,而是它们在`mChildren`列表中的位置,因此`direction`仅有按照索引递增或递减俩种方向**


### 3.4 下一个焦点控件的查找

主要是对于 键盘操作,即非触摸模式情况下的分析


# 4. 输入事件派发的综述

已知Android输入系统派发的终点是`InputEventReceiver`(根据深入理解Android第五章得出),那么作为控件系统最高级别的管理者`ViewRootImpl`,其便是`InputEventReceiver`的一个用户,它从`InputEventReceiver`中获取事件,然后将它们按照一定流程派发给所有感兴趣的对象,包括`View,PhoneWindow,Activity,Dialog`等,因此从`InputEventReceiver.onInputEvent()`开始讨论


## 4.1 ViewRootImpl的输入事件队列

在`ViewRootImpl.setView()`方法中,会利用WMS分配的`InputChannel`以及当前线程的`Looper`创建`InputEventReceiver`的子类`WindowInputEventReceiver`的一个实例,并保存在`ViewRootImpl.mInputEventReceiver`中.**这标志着从设备驱动到本窗口的输入事件通道的正式建立,每当有输入事件到来,`ViewRootImpl`都可以通过`WindowInputEventReceiver.onInputEvent()`回调获得该事件并对其进行处理**


    final class WindowInputEventReceiver extends InputEventReceiver {
        public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) {
            super(inputChannel, looper);
        }

        @Override
        public void onInputEvent(InputEvent event, int displayId) {
			// 将输入事件入队
			// 注意第三个参数为true
            enqueueInputEvent(event, this, 0, true);
        }

        @Override
        public void onBatchedInputEventPending() {
            if (mUnbufferedInputDispatch) {
                super.onBatchedInputEventPending();
            } else {
                scheduleConsumeBatchedInput();
            }
        }

        @Override
        public void dispose() {
            unscheduleConsumeBatchedInput();
            super.dispose();
        }
    }

### 4.1.1 ViewRootImpl.enqueueInputEvent()

    void enqueueInputEvent(InputEvent event,
            InputEventReceiver receiver, int flags, boolean processImmediately) {
        adjustInputEventForCompatibility(event);

		//将InputEvent 和对应的InputEventReceiver 封装为一个QueuedInputEvent
        QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);

     	//将新建的QueuedInputEvent 追加到mPendingInputEventTail所表示的单向链表中
		// ViewRootImpl 将会沿着链表从头到尾的逐个处理输入事件
        QueuedInputEvent last = mPendingInputEventTail;
        if (last == null) {
            mPendingInputEventHead = q;
            mPendingInputEventTail = q;
        } else {
            last.mNext = q;
            mPendingInputEventTail = q;
        }
        mPendingInputEventCount += 1;

        if (processImmediately) {
			//直接在当前线程中对输入事件进行处理
            doProcessInputEvents();
        } else {
			//转到主线程中进行处理
            scheduleProcessInputEvents();
        }
    }

- `QueueInputEvent` 是输入事件在`ViewRootImpl`中的存在形式

- 对于正常事件来说`processImmediately`通常为true


### 4.1.2 ViewRootImpl.doProcessInputEvents()


    void doProcessInputEvents() {
        // 处理输入事件队列中的事件
        while (mPendingInputEventHead != null) {
			........省略代码............
			//该方法会完成单个事件的整个处理流程
            deliverInputEvent(q);
        }

		........省略代码............
    }

- 该方法中,会将所有的输入事件都处理完毕再退出,换言之就是在处理完所有输入事件之前 会一直占用主线程

	这种行为主要是为了节省 因为输入事件而导致的`requestLayout()`或`invalidate()`操作, 处理完所有事件之后 由一次`performTraversals()`统一完成


## 4.2 事件处理逻辑的分歧(ViewRootImpl)

    private void deliverInputEvent(QueuedInputEvent q) {

        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0);
        }

        InputStage stage;
        if (q.shouldSendToSynthesizer()) {
            stage = mSyntheticInputStage;
        } else {
            stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;
        }

        if (stage != null) {
            stage.deliver(q);
        } else {
            finishInputEvent(q);
        }
    }

### 4.2.1 InputEventConsistencyVerifier.onInputEvent()

    public void onInputEvent(InputEvent event, int nestingLevel) {
        if (event instanceof KeyEvent) {
			//处理按键事件
            final KeyEvent keyEvent = (KeyEvent)event;
            onKeyEvent(keyEvent, nestingLevel);
        } else {
            final MotionEvent motionEvent = (MotionEvent)event;
            if (motionEvent.isTouchEvent()) {
				//处理触摸事件
                onTouchEvent(motionEvent, nestingLevel);
            } else if ((motionEvent.getSource() & InputDevice.SOURCE_CLASS_TRACKBALL) != 0) {
				//处理轨迹球事件
                onTrackballEvent(motionEvent, nestingLevel);
            } else {
				//处理其他Motion事件,如悬浮(Hover),游戏手柄等
                onGenericMotionEvent(motionEvent, nestingLevel);
            }
        }
    }

- 根据`InputEvent`的类型 或 `Source`的不同,会分别用4个方法处理4种类型的事件

	1. `onKeyEvent()`:用于派发按键类型的事件. 基于焦点的派发策略
	2. `onTouchEvent()`:用于派发标准的触摸事件. 基于位置的派发策略
	3. `onTrackballEvent()`: 用于派发轨迹球事件.
	4. `onGenericMotionEvent()`:派发其他的`Motion`事件


## 4.3 事件处理逻辑的终点(ViewRootImpl)

无论事件处理逻辑有多少个处理逻辑,应输入系统事件发送循环的要求,最终都会调用`ViewRootImpl.finishInputEvent()`, 这个方法会向`InputDispatcher`发送输入事件处理完毕的反馈,同时也标志着一条输入事件的处理流程的结束

    private void finishInputEvent(QueuedInputEvent q) {
		// 回收输入事件,并向InputDispatcher发送反馈
        if (q.mReceiver != null) {
			// 如果mReceiver 不为空,表示这是一个来自InputDispatcher的事件,需要向InputDispatcher发送反馈
			// 事件实例的回收由InputDispatcher完成
            boolean handled = (q.mFlags & QueuedInputEvent.FLAG_FINISHED_HANDLED) != 0;
            q.mReceiver.finishInputEvent(q.mEvent, handled);
        } else {
			//mReceiver为空,说明这是ViewRootImpl自行创建的事件!
			// 此时只需要将事件实例回收即可
            q.mEvent.recycleIfNeededAfterDispatch();
        }
		// 回收不再有效的QueuedInputEvent实例
		// 被回收的实例会组成一个 mQueuedInputEventPool 为头部的单向链表
		// 方便下次obtainQueuedInputEvent()时进行复用
        recycleQueuedInputEvent(q);
    }

# 5. 事件的派发分析

根据 第四节可知,事件处理会根据`InputEvent`类型 或 `Source`类型采取不同的处理逻辑,现在仅分析触摸事件

## 5.1 触摸事件的派发

触摸事件是基于位置进行派发,由于坐标系变换,多点触摸的存在十分复杂

`ViewRootImpl`并不需要将触摸事件派发给输入法,因为`InputDispatcher`会将点击到输入法的窗口的事件直接派发给它,而不需要通过`ViewRootImpl`

## 5.2 InputEventConsistencyVerifier.onTouchEvent()


	/**
		1. `nestingLevel = 0`,表示被View自己调用
		2. `nestingLevel = 1`,表示被View的子类调用

		如果事件已经在更高级的nestingl中被检查,那么它将不用被重复检查
	*/
    public void onTouchEvent(MotionEvent event, int nestingLevel) {
		// 如果当前事件不是touch事件的最后一个cancel事件,返回true
        if (!startEvent(event, nestingLevel, EVENT_TYPE_TOUCH)) {
            return;
        }

        final int action = event.getAction();
		// 判断action是否是 按下,取消,越界中的一个
        final boolean newStream = action == MotionEvent.ACTION_DOWN
                || action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_OUTSIDE;
        if (newStream && (mTouchEventStreamIsTainted || mTouchEventStreamUnhandled)) {
            mTouchEventStreamIsTainted = false;
            mTouchEventStreamUnhandled = false;
            mTouchEventStreamPointers = 0;
        }
        if (mTouchEventStreamIsTainted) {
            event.setTainted(true);
        }

        try {
            ensureMetaStateIsNormalized(event.getMetaState());

            final int deviceId = event.getDeviceId();
            final int source = event.getSource();

            if (!newStream && mTouchEventStreamDeviceId != -1
                    && (mTouchEventStreamDeviceId != deviceId
                            || mTouchEventStreamSource != source)) {
                problem("Touch event stream contains events from multiple sources: "
                        + "previous device id " + mTouchEventStreamDeviceId
                        + ", previous source " + Integer.toHexString(mTouchEventStreamSource)
                        + ", new device id " + deviceId
                        + ", new source " + Integer.toHexString(source));
            }
            mTouchEventStreamDeviceId = deviceId;
            mTouchEventStreamSource = source;

            final int pointerCount = event.getPointerCount();
            if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
                switch (action) {
                    case MotionEvent.ACTION_DOWN:
                        if (mTouchEventStreamPointers != 0) {
                            problem("ACTION_DOWN but pointers are already down.  "
                                    + "Probably missing ACTION_UP from previous gesture.");
                        }
                        ensureHistorySizeIsZeroForThisAction(event);
                        ensurePointerCountIsOneForThisAction(event);
                        mTouchEventStreamPointers = 1 << event.getPointerId(0);
                        break;
                    case MotionEvent.ACTION_UP:
                        ensureHistorySizeIsZeroForThisAction(event);
                        ensurePointerCountIsOneForThisAction(event);
                        mTouchEventStreamPointers = 0;
                        mTouchEventStreamIsTainted = false;
                        break;
                    case MotionEvent.ACTION_MOVE: {
                        final int expectedPointerCount =
                                Integer.bitCount(mTouchEventStreamPointers);
                        if (pointerCount != expectedPointerCount) {
                            problem("ACTION_MOVE contained " + pointerCount
                                    + " pointers but there are currently "
                                    + expectedPointerCount + " pointers down.");
                            mTouchEventStreamIsTainted = true;
                        }
                        break;
                    }
                    case MotionEvent.ACTION_CANCEL:
                        mTouchEventStreamPointers = 0;
                        mTouchEventStreamIsTainted = false;
                        break;
                    case MotionEvent.ACTION_OUTSIDE:
                        if (mTouchEventStreamPointers != 0) {
                            problem("ACTION_OUTSIDE but pointers are still down.");
                        }
                        ensureHistorySizeIsZeroForThisAction(event);
                        ensurePointerCountIsOneForThisAction(event);
                        mTouchEventStreamIsTainted = false;
                        break;
                    default: {
                        final int actionMasked = event.getActionMasked();
                        final int actionIndex = event.getActionIndex();
                        if (actionMasked == MotionEvent.ACTION_POINTER_DOWN) {
                            if (mTouchEventStreamPointers == 0) {
                                problem("ACTION_POINTER_DOWN but no other pointers were down.");
                                mTouchEventStreamIsTainted = true;
                            }
                            if (actionIndex < 0 || actionIndex >= pointerCount) {
                                problem("ACTION_POINTER_DOWN index is " + actionIndex
                                        + " but the pointer count is " + pointerCount + ".");
                                mTouchEventStreamIsTainted = true;
                            } else {
                                final int id = event.getPointerId(actionIndex);
                                final int idBit = 1 << id;
                                if ((mTouchEventStreamPointers & idBit) != 0) {
                                    problem("ACTION_POINTER_DOWN specified pointer id " + id
                                            + " which is already down.");
                                    mTouchEventStreamIsTainted = true;
                                } else {
                                    mTouchEventStreamPointers |= idBit;
                                }
                            }
                            ensureHistorySizeIsZeroForThisAction(event);
                        } else if (actionMasked == MotionEvent.ACTION_POINTER_UP) {
                            if (actionIndex < 0 || actionIndex >= pointerCount) {
                                problem("ACTION_POINTER_UP index is " + actionIndex
                                        + " but the pointer count is " + pointerCount + ".");
                                mTouchEventStreamIsTainted = true;
                            } else {
                                final int id = event.getPointerId(actionIndex);
                                final int idBit = 1 << id;
                                if ((mTouchEventStreamPointers & idBit) == 0) {
                                    problem("ACTION_POINTER_UP specified pointer id " + id
                                            + " which is not currently down.");
                                    mTouchEventStreamIsTainted = true;
                                } else {
                                    mTouchEventStreamPointers &= ~idBit;
                                }
                            }
                            ensureHistorySizeIsZeroForThisAction(event);
                        } else {
                            problem("Invalid action " + MotionEvent.actionToString(action)
                                    + " for touch event.");
                        }
                        break;
                    }
                }
            } else {
                problem("Source was not SOURCE_CLASS_POINTER.");
            }
        } finally {
            finishEvent();
        }
    }

