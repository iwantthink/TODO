# 输入事件的派发

[深入理解Android 卷iii PDF版]()

# 1. 简介

控件树中的输入事件派发是由`ViewRootImpl`为起点,沿着控件树逐层传递给目标控件,最终再回到`ViewRootImpl`的一个环形过程

事件派发的过程发生在创建`ViewRootImpl`的主线程中,但却独立与`ViewRootImpl.performTraversals()`之外,即输入事件的派发并不依赖于`ViewRootImpl`的`心跳`作为动力. **它的动力来源于`InputEventReceiver`的`Looper`,当一个输入事件被派发给`ViewRootImpl`所在的窗口时,`Looper`会被唤醒并触发`InputEventReceiver.onInputEvent()`回调,控件树的输入事件派发起始于这一回调.**


# 2. 触摸模式和焦点

Android同时支持按键与触摸俩种操作方式,并且可以在俩者之间自由切换

可以获取焦点的控件分为俩类:

1. 任何情况下都可以获取焦点的控件 ,如文本输入框
2. 仅在键盘操作时可以获取焦点的控件,如菜单项,按钮等

**触摸模式(TouchMode)**是为了管理俩者的差异而引入的概念,Android通过进入或退出触摸模式实现二者无缝切换 . 

- 在非触摸模式下:

	文本框,按钮,菜单项等都可以获取焦点,并且可以通过方向键使得焦点在这些控件之间切换

- 在触摸模式下:

	某些控件如菜单项,按钮将不再可以保持或获取焦点,而文本框则仍然可以保持或获取焦点


**触摸模式**是一个系统级的概念,就是说会对所有窗口产生影响.系统是否处于触摸模式取决WMS中的一个成员变量`mInTouchMode`

    /**
     * Whether the UI is currently running in touch mode (not showing
     * navigational focus because the user is directly pressing the screen).
     */
    boolean mInTouchMode;

- 退出触摸模式的操作有  

	1. 按下方向键
	2. 通过键盘按下字母键
	3. 执行了`View.requestFocusFromTouch()`

- 进入触摸模式的操作:

	1. 用户在窗口上进行了点击操作 . 窗口的`ViewRootImpl`会识别上述操作,然后通过WMS的接口`setInTouchMode()`设置`mInTouchMode`的值

	**只有拥有`ViewRootImpl`的窗口才能影响触摸模式,或对触摸模式产生响应**

系统进入或退出触摸模式对控件系统的最主要的影响是 其对焦点的选择策略



# 3 控件焦点

控件的焦点影响按键事件的派发,还影响了控件的表现形式(拥有焦点的控件往往会高亮显示以区分)

## 3.1 获取焦点的条件

控件获取焦点的方式很多,例如从控件树中按照一定策略查找到某个控件并使其获得焦点,或用户通过方向键选择某个控件使其获得焦点 .**而最基本的方式是通过`View.requestFocus()`**


`View.requestFocus()`的实现有俩种,即`View`和`ViewGroup`是不同的

- 当调用的控件为View时,表示期望此View能够获取焦点

- 当调用的控件为ViewGroup时,则会根据一定的焦点选择策略选择一个子控件或者ViewGroup本身作为焦点


### 3.1.1 View的requestFocus()

    public final boolean requestFocus() {
        return requestFocus(View.FOCUS_DOWN);
    }

- `View.FOCUS_DOWN`表示焦点的寻找方向. 当本控件是一个`ViewGroup`时将会从左上角开始沿着这个方向查找可以获取焦点的子控件,由于当前分析的是控件为View的情况,所以该参数无效


    public final boolean requestFocus(int direction) {
        return requestFocus(direction, null);
    }

- `Rect`参数表示上一个焦点控件的区域 . 表示从哪个位置开始沿着`direction`所指定的方向查找焦点控件.仅当控件是`ViewGroup`时有意义


    public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
        return requestFocusNoSearch(direction, previouslyFocusedRect);
    }

- 这个俩个参数的重载方法便是`View`和`ViewGroup`对焦点控件查找的分界点

	在`View`类型的控件中,直接调用了`View.requestFocusNoSearch()`,代表的含义就是无需查找,直接使本控件获取焦点


    private boolean requestFocusNoSearch(int direction, Rect previouslyFocusedRect) {
        // 首先必须是Focusable,另外不可见的控件也不能获取焦点
		// 可以通过View.setFocusable()进行设置
        if ((mViewFlags & FOCUSABLE) != FOCUSABLE
                || (mViewFlags & VISIBILITY_MASK) != VISIBLE) {
            return false;
        }

        // 如果系统目前处于触摸模式,则要求此控件必须可以在触摸模式下可以拥有焦点
        if (isInTouchMode() &&
            (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags & FOCUSABLE_IN_TOUCH_MODE))) {
               return false;
        }

        // need to not have any parents blocking us
		// 判断是否存在任意父控件的DescendantFocusability取值为FOCUS_BLOCK_DESCENDANTS,意义为阻止此控件获取焦点
        if (hasAncestorThatBlocksDescendantFocus()) {
            return false;
        }

		//通过此方法使得控件获取焦点
        handleFocusGainInternal(direction, previouslyFocusedRect);
        return true;
    }

**控件能否获取焦点有一下俩个要求:**

1. 并不是所有的控件都能够获取焦点

	控件系统通过`View.setFocusable()`设置控件能否获取焦点. 该方法会将`NOT_FOCUSABLE`或`FOCUSABLE`标记加入`View.mViewFlags`成员中

	**但是当控件持有`FOCUSABLE`标记时,也不一定能够获取焦点**. 控件系统通过`View.setFocusableInTouchMode()`区分这类控件,该方法会将`FOCUSABLE_IN_TOUCH_MODE`标记加入`View.mViewFlags`中

	**当控件处于触摸模式时,仅当拥有`FOCUSABLE_IN_TOUCH_MODE`标记的控件才能获取焦点**

2. 控件能否获取焦点还取决于其父控件的特性`DescendantFocusability`,这一特性描述了子控件与父控件之间的焦点获取策略

	`DescendantFocusability`存在三种取值,例如在`FOCUS_BLOCK_DESCENDANTS`时 父控件会阻止子控件获取焦点


**因此控件是否能够获取焦点的策略如下:**

1. 当`View.mViewFlags`存在`NOT_FOCUSABLE`标记时,无法获取焦点

2. 当其父控件的`DescendantFocusability`取值为`FOCUS_BLOCK_DESCENDANTS`时,无法获取焦点

3. 当`View.mViewFlags`存在`FOCUSABLE`标记时,有俩种情况

	- 位于非触摸模式,控件可以获取焦点
	- 位于触摸模式,控件的`View.mViewFlags`必须持有`FOCUSABLE_IN_TOUCH_MODE`标记才可以获取焦点


### 3.1.2 获取焦点!

`View.handleFocusGainInternal()`

    void handleFocusGainInternal(@FocusRealDirection int direction, Rect previouslyFocusedRect) {

        if ((mPrivateFlags & PFLAG_FOCUSED) == 0) {
			//将PFLAG_FOCUSED加入mPrivateFlags中
			// 这便表示此控件已经拥有焦点!
            mPrivateFlags |= PFLAG_FOCUSED;

            View oldFocus = (mAttachInfo != null) ? getRootView().findFocus() : null;

			//将焦点变换通知其父控件
			// 这一操作主要是为了保证控件树中仅有一个控件拥有焦点!!!
			// 并且在ViewRootImpl中触发一次遍历从而进行重绘
            if (mParent != null) {
                mParent.requestChildFocus(this, this);
                updateFocusedInCluster(oldFocus, direction);
            }

			
            if (mAttachInfo != null) {
                mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, this);
            }
			//通知对此控件焦点变换感兴趣的监听者
            onFocusChanged(true, direction, previouslyFocusedRect);
			//更新控件的Drawable状态.是的控件在绘制中出现高亮显示
            refreshDrawableState();
        }
    }

- `PFLAG_FOCUSED`是一个控件是否拥有焦点的最直接体现,但这一标记仅体现了焦点在个体级别上的特性,而`mParent.requestChildFocus()`则体现了焦点在控件树级别的特性

### 3.1.3 控件树中的焦点

`mParent.requestChildFocus()`方法是定义在`ViewParent`接口中的方法,其实现者为`ViewGroup`和`ViewRootImpl`.