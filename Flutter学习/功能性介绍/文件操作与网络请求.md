# 文件操作与网络请求
[文件操作与网络请求](https://github.com/flutterchina/flutter-in-action/blob/master/docs/chapter10/index.md)

# 1. 文件操作

Dart的IO库包含了文件读写的相关类，它属于Dart语法标准的一部分，所以通过Dart IO库，无论是Dart VM下的脚本还是Flutter，都是通过Dart IO库来操作文件的

- **Flutter和Dart VM相比,有一个重要差异是文件系统路径不同**，这是因为Dart VM是运行在PC或服务器操作系统下，而Flutter是运行在移动操作系统中，因此它们的文件系统会有一些差异

# 2. APP目录

**Android和iOS的应用存储目录不同**，`PathProvider` 插件提供了一种平台透明的方式来访问设备文件系统上的常用位置,该类当前支持访问三个文件系统位置：

- **临时目录**: 可以使用 `getTemporaryDirectory()` 来获取临时目录. 系统可随时清除的临时目录（缓存

	在iOS上，这对应于`NSTemporaryDirectory()` 返回的值
	
	在Android上，这是`getCacheDir()`返回的值。

- **文档目录**: 可以使用`getApplicationDocumentsDirectory()`来获取应用程序的文档目录，该目录用于存储只有自己可以访问的文件。只有当应用程序被卸载时，系统才会清除该目录

	在iOS上，这对应于`NSDocumentDirectory`。在Android上，这是`AppData`目录

- **外部存储目录**：可以使用`getExternalStorageDirectory()`来获取外部存储目录，如SD卡；由于iOS不支持外部目录，所以在iOS下调用该方法会抛出`UnsupportedError `异常，而在Android下结果是android SDK中`getExternalStorageDirectory()`的返回值

**获取到本地文件相关的信息之后可以使用[Dart io](https://api.dartlang.org/stable/2.4.0/dart-io/dart-io-library.html)进行操作**


# 3. 通过HttpClient发起HTTP请求

Dart IO库中提供了Http请求的一些类，可以直接使用`HttpClient`来发起请求。使用`HttpClient`发起请求分为五步：

1. 创建一个HttpClient

		HttpClient httpClient = new HttpClient();

2. 打开Http连接，设置请求头

		HttpClientRequest request = await httpClient.getUrl(uri);

	这一步可以使用任意Http method，如`httpClient.post(...)`、`httpClient.delete(...)`等。**如果包含`Query`参数，可以在构建uri时添加，如**：

		Uri uri=Uri(scheme: "https", host: "flutterchina.club", queryParameters: {
		    "xx":"xx",
		    "yy":"dd"
		  });

	通过`HttpClientRequest`可以设置请求header，如：

		request.headers.add("user-agent", "test");

	如果是post或put等可以携带请求体方法，可以通过`HttpClientRequest`对象发送request body，如：

		String payload="...";
		request.add(utf8.encode(payload)); 
		//request.addStream(_inputStream); //可以直接添加输入流

3. 等待连接服务器

		HttpClientResponse response = await request.close();

	这一步完成后，请求信息就已经发送给服务器了，返回一个`HttpClientResponse`对象，它包含响应头（header）和响应流(响应体的Stream)，接下来就可以通过读取响应流来获取响应内容。

4. 读取响应内容

		String responseBody = await response.transform(utf8.decoder).join();

	通过读取响应流来获取服务器返回的数据，在读取时可以设置编码格式，这里是utf8

5. 请求结束，关闭HttpClient

		httpClient.close();

	关闭client后，通过该client发起的所有请求都会中止


## 3.1 HttpClient配置


属性	|含义
---|---
`idleTimeout`	|对应请求头中的keep-alive字段值，为了避免频繁建立连接，httpClient在请求结束后会保持连接一段时间，超过这个阈值后才会关闭连接
`connectionTimeout`	|和服务器建立连接的超时，如果超过这个值则会抛出SocketException异常
`maxConnectionsPerHost`	|同一个host，同时允许建立连接的最大数量
`autoUncompress`	|对应请求头中的Content-Encoding，如果设置为true，则请求头中Content-Encoding的值为当前HttpClient支持的压缩算法列表，目前只有"gzip"
`userAgent`	|对应请求头中的User-Agent字段

可以发现，有些属性只是为了更方便的设置请求头，对于这些属性，完全可以通过`HttpClientRequest`直接设置`header`，不同的是**通过`HttpClient`设置的对整个`httpClient`都生效，而通过`HttpClientRequest`设置的只对当前请求生效**

## 3.2 HTTP请求认证

**Http协议的认证（`Authentication`）机制可以用于保护非公开资源**。如果Http服务器开启了认证，那么用户在发起请求时就需要携带用户凭据，例如在浏览器中访问了启用Basic认证的资源时，浏览就会弹出一个登录框，如：

![](https://camo.githubusercontent.com/cb4dd593a36f0adef918b3a43f553b179a9fe8b4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f666c75747465726368696e612f666c75747465722d696e2d616374696f6e40312e302f646f63732f696d67732f696d6167652d32303138313033313131343230373531342e706e67)


**Basic认证的基本过程：**

1. 客户端发送http请求给服务器，服务器验证该用户是否已经登录验证过了，如果没有的话，服务器会返回一个401 Unauthozied给客户端，并且在响应header中添加一个 “WWW-Authenticate” 字段，例如：

		WWW-Authenticate: Basic realm="admin"

2. 客户端得到响应码后，将用户名和密码进行base64编码（格式为用户名:密码），设置请求头Authorization，继续访问 :

		Authorization: Basic YXXFISDJFISJFGIJIJG

	服务器验证用户凭据，如果通过就返回资源内容


**Http的认证方式除了Basic认证之外还有：Digest认证、Client认证、Form Based认证等**

- 目前Flutter的`HttpClient`只支持Basic和Digest两种认证方式，这两种认证方式最大的区别是发送用户凭据时，对于用户凭据的内容，前者只是简单的通过Base64编码（可逆），而后者会进行哈希运算，相对来说安全一点点，但是为了安全起见，无论是采用Basic认证还是Digest认证，都应该在Https协议下，这样可以防止抓包和中间人攻击

### 3.2.1 Http认证的示例

`HttpClient`关于Http认证的方法和属性：

1. **添加用户凭据**:

		addCredentials(Uri url, String realm, HttpClientCredentials credentials)

	该方法用于添加用户凭据,使用方式如下:

		httpClient.addCredentials(_uri,
		 "admin", 
		  new HttpClientBasicCredentials("username","password"), //Basic认证凭据
		);

	如果是Digest认证，可以创建Digest认证凭据：

		HttpClientDigestCredentials("username","password")


3. 设置回调函数,**当服务器需要用户凭据且该用户凭据未被添加时，httpClient会调用此回调**

		set authenticate(Future<bool> f(Uri url, String scheme, String realm))

	这是一个setter，接收的参数是一个名称为f的回调函数，其返回`Future`，在这个回调当中，一般会调用`addCredential()`来动态添加用户凭证，例如：
		
		httpClient.authenticate=(Uri url, String scheme, String realm) async{
		  if(url.host=="xx.com" && realm=="admin"){
		    httpClient.addCredentials(url,
		      "admin",
		      new HttpClientBasicCredentials("username","pwd"), 
		    );
		    return true;
		  }
		  return false;
		};
		
**一个建议是，如果所有请求都需要认证，那么应该在`HttpClient`初始化时就调用`addCredentials()`来添加全局凭证，而不是去动态添加**

## 3.3 代理

`HttpClient`可以通过`findProxy`setter来设置代理策略

	set findProxy(String f(Uri url));

示例(将所有请求通过代理服务器（192.168.1.2:8888）发送出去)

	client.findProxy = (uri) {
	    // 如果需要过滤uri，可以手动判断
	    return "PROXY 192.168.1.2:8888";
	};

- `findProxy` 回调返回值是一个遵循浏览器PAC脚本格式的字符串，详情可以查看API文档，如果不需要代理，返回"DIRECT"即可

**在APP开发中，很多时候需要抓包来调试，而抓包软件(如charles)就是一个代理，这时就可以将请求发送到抓包软件，然后就可以在抓包软件中看到请求的数据了**

- 有时代理服务器也启用了身份验证，这和http协议的认证是相似的，`HttpClient`提供了对应的Proxy认证方法和属性：

		set authenticateProxy(
		    Future<bool> f(String host, int port, String scheme, String realm));
		void addProxyCredentials(
		    String host, int port, String realm, HttpClientCredentials credentials);

## 3.4 证书校验

**`Https`中为了防止通过伪造证书而发起的中间人攻击，客户端应该对自签名或非CA颁发的证书进行校验**

`HttpClient`对证书校验的逻辑如下：

1. 如果请求的Https证书是可信CA颁发的，并且访问host包含在证书的domain列表中(或者符合通配规则)并且证书未过期，则验证通过

2. 如果第一步验证失败，但在创建HttpClient时，已经通过SecurityContext将证书添加到证书信任链中，那么当服务器返回的证书在信任链中的话，则验证通过

3. 如果1、2验证都失败了，如果用户提供了`badCertificateCallback`回调，则会调用它，如果回调返回true，则允许继续链接，如果返回false，则终止链接

- **综上所述，证书校验其实就是提供一个`badCertificateCallback`回调**

### 3.4.1 示例

假设后台服务使用的是自签名证书，证书格式是PEM格式，那么将证书的内容保存在本地字符串中，然后校验逻辑如下：

	String PEM="XXXXX";//可以从文件读取
	...
	httpClient.badCertificateCallback=(X509Certificate cert, String host, int port){
	  if(cert.pem==PEM){
	    return true; //证书一致，则允许发送数据
	  }
	  return false;
	};

- **`X509Certificate`是证书的标准格式，包含了证书除私钥外所有信息**，读者可以自行查阅文档

- 上面的示例没有校验host，是因为只要服务器返回的证书内容和本地的保存一致就已经能证明是自己的服务器了（而不是中间人），host验证通常是为了防止证书和域名不匹配

### 3.4.2 本地证书信任链

**对于自签名的证书，可以将其添加到本地证书信任链中，这样证书验证时就会自动通过，而不会再走到`badCertificateCallback`回调中**：

	SecurityContext sc=new SecurityContext();
	//file为证书路径
	sc.setTrustedCertificates(file);
	//创建一个HttpClient
	HttpClient httpClient = new HttpClient(context: sc);


- **通过`setTrustedCertificates()`设置的证书格式必须为PEM或PKCS12**，如果证书格式为PKCS12，则需将证书密码传入，这样则会在代码中暴露证书密码，所以客户端证书校验不建议使用PKCS12格式的证书

## 3.5 总结

**`HttpClient`提供的这些属性和方法最终都会作用在请求header里，完全可以通过手动去设置header来实现，之所以提供这些方法，只是为了方便开发者而已**

- Http协议是一个非常重要的、使用最多的网络协议，每一个开发者都应该对http协议非常熟悉

# 4. Dio Http库

直接使用HttpClient发起网络请求是比较麻烦的，很多事情得手动处理，如果再涉及到文件上传/下载、Cookie管理等就会非常繁琐

因此使用一些第三方http请求库，用它们来发起http请求将会简单的多，例如[dio库](https://github.com/flutterchina/dio)

- dio是一个强大的Dart Http请求库，支持Restful API、FormData、拦截器、请求取消、Cookie管理、文件上传/下载、超时等

使用的基本流程：

1. 添加依赖

		dependencies:
		  dio: ^x.x.x #请使用pub上的最新版本

2. 导入dio包，并创建`Dio`实例

		import 'package:dio/dio.dart';
		Dio dio = new Dio();

3. 接下来就可以通过dio实例来发起网络请求了

	**一个`dio`实例可以发起多个http请求，一般来说，APP只有一个http数据源时，dio应该使用单例模式**


## 4.1 使用示例

**发起`GET`请求:**

	Response response;
	response=await dio.get("/test?id=12&name=wendu")
	print(response.data.toString());

对于GET请求可以将query参数通过对象来传递，上面的代码等同于：

	response=await dio.get("/test",queryParameters:{"id":12,"name":"wendu"})
	print(response);


**发起`POST`请求:**

	response=await dio.post("/test",data:{"id":12,"name":"wendu"})

**发起多个并发请求:**

	response= await Future.wait([dio.post("/info"),dio.get("/token")]);

**下载文件:**

	response=await dio.download("https://www.google.com/",_savePath);

**发送`FormData`:**

	FormData formData = new FormData.from({
	   "name": "wendux",
	   "age": 25,
	});
	response = await dio.post("/info", data: formData)

- 如果发送的数据是`FormData`，则dio会将请求`header`的`contentType`设为`multipart/form-data`

- 通过`FormData`上传多个文件:

		FormData formData = new FormData.from({
		   "name": "wendux",
		   "age": 25,
		   "file1": new UploadFileInfo(new File("./upload.txt"), "upload1.txt"),
		   "file2": new UploadFileInfo(new File("./upload.txt"), "upload2.txt"),
		     // 支持文件数组上传
		   "files": [
		      new UploadFileInfo(new File("./example/upload.txt"), "upload.txt"),
		      new UploadFileInfo(new File("./example/upload.txt"), "upload.txt")
		    ]
		});
		response = await dio.post("/info", data: formData)


**dio内部仍然使用HttpClient发起的请求，所以代理、请求认证、证书校验等和HttpClient是相同的**，Dio提供了`onHttpClientCreate` 设置回调，该回调可以设置上述操作，例如：

	(dio.httpClientAdapter as DefaultHttpClientAdapter).onHttpClientCreate = (client) {
	    //设置代理 
	    client.findProxy = (uri) {
	      return "PROXY 192.168.1.2:8888";
	    };
	    //校验证书
	    httpClient.badCertificateCallback=(X509Certificate cert, String host, int port){
	      if(cert.pem==PEM){
	      return true; //证书一致，则允许发送数据
	     }
	     return false;
	    };   
	  };

- **`onHttpClientCreate` 会在当前`Dio`实例内部需要创建`HttpClient`时调用**，所以通过此回调配置`HttpClient`会对整个dio实例生效，**如果想针对某个应用请求单独的代理或证书校验策略，可以创建一个新的dio实例即可**

除了这些基本的用法，dio还支持请求配置、拦截器等，官方资料比较详细，故本书不再赘述

## 4.1 Http分块下载实例

[实例：Http分块下载](https://github.com/flutterchina/flutter-in-action/blob/master/docs/chapter10/download_with_chunks.md)




