# 文件操作

[Working With Files](https://docs.gradle.org/current/userguide/working_with_files.html)

[文件操作-极客学院](http://wiki.jikexueyuan.com/project/GradleUserGuide-Wiki/working_with_files/README.html)

[硬编码-wiki](https://zh.wikipedia.org/wiki/%E5%AF%AB%E6%AD%BB)

# 1. 简介

大多数构建工作需要操作文件，因此Gradle增加了详尽的API帮助处理与文件相关的操作


文件相关的API包含俩部分

1. 指定哪些文件或目录需要处理

2. 指定如何去处理


# 2 复制单个文件

通过创建一个类型为Gradle内置的`Copy`类型的任务，然后配置其输入文件路径和输出文件路径，即可实现文件复制


## 2.1 使用File对象

接下来展示一个示例，将一个生成的报告复制到一个指定的文件夹中，以用来生成Zip或TAR

	task copyReport(type: Copy) {
	    from file("$buildDir/reports/my-report.pdf")
	    into file("$buildDir/toArchive")
	}
	
	
-  `Project.file（java.lang.Object）`方法用于创建相对于当前项目的文件或目录，并且是使构建脚本无视项目路径进行工作的常用方法	

- `Copy.from(java.lang.Object... sourcePaths)`指定了被复制的文件或目录

- `Copy.into(java.lang.Object destDir)`:指定了复制到什么目录
	
- 甚至可以不去使用`Project.file()`方法，而直接使用路径	

## 2.2 使用隐式字符串路径

	task copyReport2(type: Copy) {
	    from "$buildDir/reports/my-report.pdf"
	    into "$buildDir/toArchive"
	}

- **尽管这里的硬编码路径用于简单的示例，但是仍然使得构建变得脆弱.最好使用单一的、可靠的来源，例如任务或共享的属性**
	
	
## 2.3 使用任务/Porject的属性
编写示例，使用任务`myReportTask`的属性outputFile作为输入地址 . 使用任务`archiveReportsTask`的属性dirToArchive作为输出地址


	task copyReport3(type: Copy) {
	    from myReportTask.outputFile
	    into archiveReportsTask.dirToArchive
	}

# 3. 复制多个文件

## 3.1 使用`from()`

**通过传递多个参数给`Copy.from(java.lang.Object... sourcePaths)`方法，即可实现复制多个文件**

	task copyReportsForArchiving(type: Copy) {
	    from "$buildDir/reports/my-report.pdf", "src/docs/manual.pdf"
	    into "$buildDir/toArchive"
	}

- 使用俩个`from`方法并传递单个参数同样	可以实现

- 将文件夹作为输入，将会复制该文件夹下的所有文件

## 3.2 使用flat filter

**如果想复制一个文件夹中的多个文件，而不想一个个的去指定文件。可以通过添加正则规则来指定复制的规范**

	task copyPdfReportsForArchiving(type: Copy) {
	    from "$buildDir/reports"
	    include "*.pdf"
	    into "$buildDir/toArchive"
	}

- 指定`reports`文件夹下，仅复制文件名符合`*.pdf`规则的,并且仅处理直接在该文件夹下的文件


![](http://ww1.sinaimg.cn/large/6ab93b35ly1g2e1gvmo4fj21zn0iq0ti.jpg)


## 3.3 使用deep filter

通过使用Ant 风格的glob pattern(shell样式的正则表达式),可以将子文件夹下的文件也添加进来

	task copyAllPdfReportsForArchiving(type: Copy) {
	    from "$buildDir/reports"
	    include "**/*.pdf"
	    into "$buildDir/toArchive"
	}

![](http://ww1.sinaimg.cn/large/6ab93b35ly1g2e1qi51s4j22450iqjs9.jpg)


- `deep filter`有一个副作用是会生成被拷贝文件夹一样的文件结构。 如果只想复制文件而不想要其文件结构，可以使用`fileTree(dir) { includes }.files `

	上述问题仅仅是Gradle构建中处理文件时可能遇到的问题之一，幸运的是Gradle几乎为所有这种问题提供给了解决方案
	
# 4. 复制目录层次结构
当`from()`方法传入文件夹作为参数时 ，拷贝会包含文件和其文件结构

## 4.1 复制整个文件夹

	task copyReportsDirForArchiving(type: Copy) {
	    from "$buildDir/reports"
	    into "$buildDir/toArchive"
	}
	
	
## 4.2 复制整个文件夹(包括其自身)	
**复制过程的关键点是如何控制目录结构复制到目标文件夹中,默认情况下在复制文件夹时，并不会将文件夹自身也复制到目标文件夹中**	
	
- 通过添加 包含正则 即可将文件夹自身也添加到目标文件夹中
	
示例：	
	
	task copyReportsDirForArchiving2(type: Copy) {
	    from("$buildDir") {
	        include "reports/**"
	    }
	    into "$buildDir/toArchive"
	}	
	
- 这里将`include`直接应用到`from()`方法中，之前的`include`是添加到整个Task中	

	复制规范中这些不同级别的粒度使得处理各种需求更加的方便，例如出现多个`from()`时，将`include()` 添加到Task中，那么会对所有的`from()`生效，如果只想对单个`from()`生效，那么可以将`include()`添加到`from()`中

	[Using child specifications](https://docs.gradle.org/current/userguide/working_with_files.html#sub:using_child_copy_specifications)



# 5. 创建存档(zip,tar,etc)

Gradle认为打包文件至存档实际上就是一个复制任务将目的地指定成一个归档文件

- 这意味着创建存档和复制文件是相似的，创建存档可以使用复制所拥有的特性

每种类型的存档都有其对应的任务类型，最常用的是`Zip`,`Tar`和`Jar`,它们都共享`Copy`类型的大多数配置，包括过滤和重命名	


## 5.1 将目录归档为ZIP

	task packageDistribution(type: Zip) {
	    archiveFileName = "my-distribution.zip"
	    destinationDirectory = file("$buildDir/dist")
	
	    from "$buildDir/toArchive"
	}
	
- 注意这里并没有直接使用`into()`,而是使用使用`archiveFileName()`和`destinationDirectory()`方法分别指定了Zip名称和Zip的存储路径

	**通常情况下，并不需要调用`archiveFileName()`和`destinationDirectory()`方法，因为大多数项目应用`Base Plugin`,其为这些属性提供了一些惯例值**	
	
	
## 5.2 使用BasePlugin提供的归档名称惯例

最常见的场景之一是将文件复制到存档的指定子目录中
		
	plugins {
	    id 'base'
	}
	
	version = "1.0.0"
	
	task packageDistribution(type: Zip) {
	    from("$buildDir/toArchive") {
	        exclude "**/*.pdf"
	    }
	
	    from("$buildDir/toArchive") {
	        include "**/*.pdf"
	        into "docs"
	    }
	}	
	
- 上面的例子将所有`PDF`类型的文件拷贝到了归档文件的`docs`目录下，其余文件都在归档文件的根目录下

# 6. 解压归档

归档文件实际上是自包含的文件系统，因此解压它们就是将文件从归档文件系统复制到本地文件系统中(复制到另外一个归档文件中也是可以的) . Gradle通过提供一些包装函数来实现这一点，这些包装函数使得归档可以作为文件树来使用(hierarchical collections)

- **通过使用 `Project.zipTree(java.lang.Object)` 和`Project.tarTree(java.lang.Object)`方法，可以将归档文件转换成`FileTree`对象**

	**`FileTree`可以被用在`from()`规范中**
	
- 请注意并没有`jarTree()`方法,因为`zipTree()`方法可以完美的为`Jars,Wars,Ears`工作	

## 6.1 解压Zip文件

	task unpackFiles(type: Copy) {
	    from zipTree("src/resources/thirdPartyResources.zip")
	    into "$buildDir/resources"
	}
	
- 与普通的复制任务一样，可以通过控制过滤器决定解压哪些文件，以及在解压时重命名文件

## 6.2 解压Zip文件的子集

可以通过`eachFile()`方法来进行更高级的处理。例如，将归档所代表的`FileTree`的不同子树分别提取到目标目录的不同路径下

	task unpackLibsDirectory(type: Copy) {
	    from(zipTree("src/resources/thirdPartyResources.zip")) {
	        include "libs/**"  // (1)
	        eachFile { fcd ->
	            fcd.relativePath = new RelativePath(true, fcd.relativePath.segments.drop(1))  // (2)
	        }
	        includeEmptyDirs = false  // (3)
	    }
	    into "$buildDir/resources"
	}
	
- 三点注释:

	1. 仅提取归档文件中`libs`文件夹下的文件的子集

	2. 通过删除文件路径中的`libs`片段，将待提取文件的路径映射目标目录下	
	3. 忽略重新映射导致的空目录
	
# 7 创建“uber”/"fat" Jar

在Java中，应用程序以及其依赖通常分别被打包到各自的Jar包中。 现在还有另外一种方法，就是将依赖的类和资源直接打包到应用程序的Jar包中(这种被称作`uber`或`fat`Jar)

Gradle使得这种方法十分容易去实现，只需要使用`Project.zipTree(java.lang.Object)`方法和`Jar`任务即可

## 7.1 创建一个Java uber/fat Jar

	plugins {
	    id 'java'
	}
	
	version = '1.0.0'
	
	repositories {
	    mavenCentral()
	}
	
	dependencies {
	    implementation 'commons-io:commons-io:2.6'
	}
	
	task uberJar(type: Jar) {
	    archiveClassifier = 'uber'
	
	    from sourceSets.main.output
	
	    dependsOn configurations.runtimeClasspath
	    from {
	        configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }.collect { zipTree(it) }
	    }
	}

- 在本例中，获取项目的`configuration.runtimeclasath.files`(运行时依赖项)，并使用`zipTree()`方法包装每个JAR文件。结果是一个ZIP文件树的集合，其内容连同应用程序的类一起复制到uber JAR中。


# 8. 创建文件夹

在任务中显示的定义文件或目录输出时，Gradle会自动管理任务的这一方面(自动生成文件或文件夹)，因为大多数的任务都需要为其所生成的内容提供一个目录去存储

- Gradle提供了`Project.mkdir(java.lang.Object)`方法以应用需要手动创建文件夹的需求，该方法在任务或构建脚本中都能使用

## 8.1 手动创建文件夹

	task ensureDirectory {
	    doLast {
	        mkdir "images"
	    }
	}

# 9. 移动文件或文件夹

Gradle并没有提供关于移动文件或文件夹的Api，但是可以通过`Apache Ant integration`去实现这一点


	task moveReports {
	    doLast {
	        ant.move file: "${buildDir}/reports",
	                 todir: "${buildDir}/toArchive"
	    }
	}

- 移动文件或文件夹可能导致破坏构建结构，因此更建议使用Copy


# 10. 在复制时修改文件名称

Gradle在复制规范中提供了`rename()`方法，这允许文件在复制过程中被重命名

	task copyFromStaging(type: Copy) {
	    from "src/main/webapp"
	    into "$buildDir/explodedWar"
	
	    rename '(.+)-staging(.+)', '$1$2'
	}

- `rename()`中可以使用正则表达式,或者可以使用一个闭包来使用更加复杂的规则去定义一个目标文件的名称


## 10.1 在复制时删除文件名

	task copyWithTruncate(type: Copy) {
	    from "$buildDir/reports"
	    rename { String filename ->
	        if (filename.size() > 10) {
	            return filename[0..7] + "~" + filename.size()
	        }
	        else return filename
	    }
	    into "$buildDir/toArchive"
	}

- 与过滤一样，可以将重命名配置到`from()`，使其作为文件子集规范的一部分，从而将重命名应用于文件子集


# 11. 删除文件和文件夹

Gradle提供了`Delete`任务类型或`Project.delete(org.gradle.api.Action)`方法来删除文件或文件夹

- 俩个方法都需要传入 `Project.files(java.lang.Object…​)`方法支持的文件或文件夹对象


## 11.1 删除一个文件夹

	task myClean(type: Delete) {
	    delete buildDir
	}

## 11.2 删除匹配规则的文件
如果想对被删除的文件进行过滤，必须得通过`FileCollection`或`FileTree`内置的方法


	task cleanTempFiles(type: Delete) {
	    delete fileTree("src").matching {
	        include "**/*.tmp"
	    }
	}


# 12. 深入理解文件路径

当需要对文件执行一些操作时，首先得知道文件在哪里，这就得通过文件路径来知道。Gradle使用标准的Java File类，该类代表了单个文件的位置，并且提供了用于处理路径集合的Api

这一小节将会介绍如何使用Gradle Api 去指定用于任务和文件操作的文件路径


## 12.1 硬编码的文件路径

硬编码指的是相关参数以常量的方式出现

许多示例都使用硬编码路径作为字符串输入，这易于理解，但是对构建来说并不好，因为路径的变化往往会导致构建失败，所以尽可能的减少对路径的处理

在可能的情况下，优先考虑使用 任务，任务的属性，项目的属性 这样的顺序来配置路径

### 12.1.1 如何减少构建中的硬编码路径

例如，如果要创建一个任务，用来打包Java应用程序的类，那么需要关注以下几个点:

	ext {
	    archivesDirPath = "$buildDir/archives"
	}
	
	task packageClasses(type: Zip) {
	    archiveAppendix = "classes"
	    destinationDirectory = file(archivesDirPath)
	
	    from compileJava
	}

- 这里的来源直接使用了`compileJava`任务作为创建归档任务的输入，同时定义了归档的输出路径为项目的属性，这样就可以在其他地方进行使用

	此外，该例子可以进一步的优化，就是通过使用`Java`插件默认的`destinationDirectory`而不是对其进行重写

- **使用任务直接作为参数的前提是该任务定义了输出，因此这种形式并不总是可用的！**


## 12.2 单个文件和文件夹

Gradle提供了`Project.file(java.lang.Object) `方法用于指定单个文件或文件夹的位置

- 相对路径相对于项目文件夹，而绝对路径保持不变

- 不要使用`new File(relative path)`，因为这会创建一个相对于当前工作目录(Current Working Directory,简称CWD)的File对象。 Gradle无法保证这个地址不发生变化，因此如果依赖于这个地址构建很可能发生崩溃

- `file()`方法可以被用于配置任何具有`File`类型属性的任务



### 12.2.1 定位文件

以下是通过给`file()`方法不同参数来定义文件的示例

	// 使用相对路径
	File configFile = file('src/config.xml')
	
	// 使用绝对路径
	configFile = file(configFile.absolutePath)
	
	// 使用具有相对路径的File对象
	configFile = file(new File('src/config.xml'))
	
	// 使用具有相对路径的java.nio.file.Path对象
	configFile = file(Paths.get('src', 'config.xml'))
	
	// 使用具有绝对路径的java.nio.file.Path对象
	configFile = file(Paths.get(System.getProperty('user.home')).resolve('global-config.xml'))

- 从上面的例子知晓，**`file()`方法可以传入 字符串，File对象,Path对象.**所有这些对象最终都会生成一个File对象


### 12.2.2 根据父项目创建路径

`file()`方法总是将相对路径 转换为相对于当前项目目录的路径（该目录可能是子项目）。例如`file("src")`在父项目中相对路径为`.../project/src`,在子项目中的相对路径就是`.../project/subProject/src`.

- 如果想要指定路径是相对于根项目目录，那就需要使用特殊的属性`Project.getRootDir()`去构建一个绝对路径

假设当前正在`dev/projects/AcmeHealth`目录下开发多项目构建，下面的代码在`AcmeHealth/subprojects/AcmePatientRecordLib/build.gradle`这个构建文件中执行，得到的结果应该是`dev/projects/AcmeHealth/shared/config.xml`

	File configFile = file("$rootDir/shared/config.xml")

## 12.3 文件集合

文件集合就是由`FileCollection`接口表示的一组文件路径。 这组文件路径不需要有任何关联，它们不必处于相同的目录中，不必具有共享的父目录

- Gradle API的许多部分都使用了文件收集，比如复制API和依赖项配置


**Gradle推荐使用`ProjectLayout.files(java.lang.Object...) `方法去指定文件集合，该方法会返回一个`FileCollection`对象. 该方法允许传入多个字符串，`File`对象,字符串集合，`File`对象集合等等，甚至可以传递一个定义了输出的Task**

- 注意：尽管`files()`方法接受`File`对象，但是不要使用`new File(relative path)`创建出来的`File`对象，因为它会使用相对于当前工作目录(CWD)的路径，对于这种路径很可能会出现变化，从而导致异常

- **注意这里使用的是`ProjectLayout`的`files()`方法，而不是`Project`的`files()`**


文件集合拥有以下几点重要属性:

1. created lazily(延迟创建)

2. iterated over(迭代)

3. filtered(过滤)

4. combined(合并)

### 12.3.1 创建文件集合
下面的例子展示了使用字符串，`File`对象，list，Path 作为`files()`参数

	FileCollection collection = layout.files('src/file1.txt',
	                                  new File('src/file2.txt'),
	                                  ['src/file3.csv', 'src/file4.csv'],
	                                  Paths.get('src', 'file5.txt'))
	                                  
	                                  

### 12.3.2 延迟创建文件集合
文件集合的延迟创建属性，对于在构建运行时评估构成的文件 特别有有用。 在下面的例子中，查询文件系统，找出特定目录下存在哪些文件，然后再放入文件集合中


	task list {
	    doLast {
	        File srcDir
	
	        // Create a file collection using a closure
	        collection = layout.files { srcDir.listFiles() }
	
	        srcDir = file('src')
	        println "Contents of $srcDir.name"
	        collection.collect { relativePath(it) }.sort().each { println it }
	
	        srcDir = file('src2')
	        println "Contents of $srcDir.name"
	        collection.collect { relativePath(it) }.sort().each { println it }
	    }
	}  

	> gradle -q list
	Contents of src
	src/dir1
	src/file1.txt
	Contents of src2
	src2/dir1
	src2/dir2

- 延迟创建的关键是将一个闭包传递给`files()`方法，闭包只需要返回`files()`方法所能接受的参数，例如`List<File>`，字符串，FileCollection等等

### 12.3.3 遍历文件集合

**遍历文件集合可以通过`each()`方法，或者`for`循环来实现。俩个方法中，文件集合都被当做一组`File`实例(即迭代遍历是File类型)**

    // Iterate over the files in the collection
    collection.each { File file ->
        println file.name
    }
    
    
### 12.3.4 使用文件集合

Gradle允许**通过`as`操作符将文件集合中的转换为其他类型**    
    

    // Convert the collection to various types
    Set set = collection.files
    Set set2 = collection as Set
    List list = collection as List
    String path = collection.asPath
    File file = collection.singleFile

    // Add and subtract collections
    def union = collection + layout.files('src/file2.txt')
    def difference = collection - layout.files('src/file2.txt')

- **文件集合支持使用运算符`+`去合并俩个文件集合，以及使用运算符`-`去文件集合A中移除文件集合B**

	**这种操作有一个很重要的特性就是它们是实时变化的（live collections）。换句话说，当以这种形式对文件集合进行操作，得到的结果将根据源文件集合实时计算!即使源文件集合是在构建过程中发生变化** 。举个例子，当文件集合A和文件集合B合并成文件集合C之后，文件集合A又添加了俩个File，那么文件集合C也会包含着俩个File
	
### 12.3.5 过滤文件集合

实时集合(`live collections`)这种特性在文件集合进行过滤时也十分重要。 

**如果想要使用一个文件集合的子集，可以使用`FileCollection.filter(org.gradle.api.specs.Spec)`方法决定哪些文件需要被保留**

下面的例子展示了如何从源文件集合中过滤出一部分文件名以`.txt`结尾的子集

    FileCollection textFiles = collection.filter { File f ->
        f.name.endsWith(".txt")
    }

	> gradle -q filterTextFiles
	src/file1.txt
	src/file2.txt
	src/file5.txt
	
- `collection`文件集合在任何时候发生改变，无论是增加或删除文件，`textFiles`文件集合都会立刻反映改变，因为它也是一个实时集合(`live collection`)

- 传递给`filter()`方法的闭包，接受一个文件为参数，并且应该返回一个布尔值(表示是否需要保留)


# 13. 文件树

**文件树是一个保留了其所包含的文件的目录结构的文件集合，Gradle提供了`FileTree`类型去形容这种类型**

- 这意味着文件树种的所有文件都具有同一个共享的父目录。


下图强调了在常见的复制文件的例子中，文件树和文件集合的区别：


![](http://ww1.sinaimg.cn/large/6ab93b35gy1g2f1qpvtenj22f11bogo7.jpg)


- 尽管`FileTree`继承自`FileCollection`,但是它们的行为却不相同。换句话说，可以在任何使用文件集合的地方使用文件树，但是请记住：文件集合是平面的文件集，而文件树是文件和目录结构的，所以如果要将`FileTree`抓换成`FileCollection`需要使用`FileTree.getFiles()`方法


		task copy(type:Copy){
			def fc = layout.files('src/resources/img/logo.png','src/resources/img/banner.jpg','src/resources/img/data.txt')
			from fc
			into 'build/resources'
		}

		task copy(type:Copy){
			def ft = fileTree('src/resources')
			from ft
			into 'build/resources'
		}

创建文件树最简单的方法就是通过`Project.fileTree（java.lang.Object`方法，其接受文件或文件夹的路径作为参数, 该方法将根据参数创建包含整个文件和文件夹的树(但是并不包含参数文件夹自身)


## 13.1 创建文件树

下面的案例演示了如何文件树的基本操作，以及如何通过`Ant-style`类型的模式过滤文件和文件夹


	// 使用一个文件夹创建一个文件树
	ConfigurableFileTree tree = fileTree(dir: 'src/main')
	
	// 为文件树添加 包含/排斥规则
	tree.include '**/*.java'
	tree.exclude '**/Abstract*'
	
	// 利用闭包创建文件树
	tree = fileTree('src') {
	    include '**/*.java'
	}
	
	// 使用map作为参数创建文件树
	tree = fileTree(dir: 'src', include: '**/*.java')
	tree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])
	tree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')
	
- 在[PatternFilterable Api](https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/util/PatternFilterable.html)中可以查看更多支持的匹配规则

- 默认情况下，`fileTree()`方法返回一个`FileTree`实例，该实例会被添加一些默认的排除规则

	[默认的排除规则](http://ant.apache.org/manual/dirtasks.html#defaultexcludes)


## 13.2 修改复制任务的Ant默认排除规则

	task forcedCopy (type: Copy) {
	    into "$buildDir/inPlaceApp"
	    from 'src/main/webapp'
	
	    doFirst {
	        ant.defaultexcludes remove: "**/.git"
	        ant.defaultexcludes remove: "**/.git/**"
	        ant.defaultexcludes remove: "**/*~"
	    }
	
	    doLast {
	        ant.defaultexcludes default: true
	    }
	}



