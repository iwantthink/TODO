# 文件操作

[Working With Files](https://docs.gradle.org/current/userguide/working_with_files.html)

[文件操作-极客学院](http://wiki.jikexueyuan.com/project/GradleUserGuide-Wiki/working_with_files/README.html)


# 1. 简介

大多数构建工作需要操作文件，因此Gradle增加了详尽的API帮助处理与文件相关的操作


文件相关的API包含俩部分

1. 指定哪些文件或目录需要处理

2. 指定如何去处理


# 2 复制单个文件

通过创建一个类型为Gradle内置的`Copy`类型的任务，然后配置其输入文件路径和输出文件路径，即可实现文件复制


## 2.1 使用File对象

接下来展示一个示例，将一个生成的报告复制到一个指定的文件夹中，以用来生成Zip或TAR

	task copyReport(type: Copy) {
	    from file("$buildDir/reports/my-report.pdf")
	    into file("$buildDir/toArchive")
	}
	
	
-  `Project.file（java.lang.Object）`方法用于创建相对于当前项目的文件或目录，并且是使构建脚本无视项目路径进行工作的常用方法	

- `Copy.from(java.lang.Object... sourcePaths)`指定了被复制的文件或目录

- `Copy.into(java.lang.Object destDir)`:指定了复制到什么目录
	
- 甚至可以不去使用`Project.file()`方法，而直接使用路径	

## 2.2 使用隐式字符串路径

	task copyReport2(type: Copy) {
	    from "$buildDir/reports/my-report.pdf"
	    into "$buildDir/toArchive"
	}

- **尽管这里的硬编码路径用于简单的示例，但是仍然使得构建变得脆弱.最好使用单一的、可靠的来源，例如任务或共享的属性**
	
	
## 2.3 使用任务/Porject的属性
编写示例，使用任务`myReportTask`的属性outputFile作为输入地址 . 使用任务`archiveReportsTask`的属性dirToArchive作为输出地址


	task copyReport3(type: Copy) {
	    from myReportTask.outputFile
	    into archiveReportsTask.dirToArchive
	}

# 3. 复制多个文件

## 3.1 使用`from()`

**通过传递多个参数给`Copy.from(java.lang.Object... sourcePaths)`方法，即可实现复制多个文件**

	task copyReportsForArchiving(type: Copy) {
	    from "$buildDir/reports/my-report.pdf", "src/docs/manual.pdf"
	    into "$buildDir/toArchive"
	}

- 使用俩个`from`方法并传递单个参数同样	可以实现

- 将文件夹作为输入，将会复制该文件夹下的所有文件

## 3.2 使用flat filter

**如果想复制一个文件夹中的多个文件，而不想一个个的去指定文件。可以通过添加正则规则来指定复制的规范**

	task copyPdfReportsForArchiving(type: Copy) {
	    from "$buildDir/reports"
	    include "*.pdf"
	    into "$buildDir/toArchive"
	}

- 指定`reports`文件夹下，仅复制文件名符合`*.pdf`规则的,并且仅处理直接在该文件夹下的文件


![](http://ww1.sinaimg.cn/large/6ab93b35ly1g2e1gvmo4fj21zn0iq0ti.jpg)


## 3.3 使用deep filter

通过使用Ant 风格的glob pattern(shell样式的正则表达式),可以将子文件夹下的文件也添加进来

	task copyAllPdfReportsForArchiving(type: Copy) {
	    from "$buildDir/reports"
	    include "**/*.pdf"
	    into "$buildDir/toArchive"
	}

![](http://ww1.sinaimg.cn/large/6ab93b35ly1g2e1qi51s4j22450iqjs9.jpg)


- `deep filter`有一个副作用是会生成被拷贝文件夹一样的文件结构。 如果只想复制文件而不想要其文件结构，可以使用`fileTree(dir) { includes }.files `

	上述问题仅仅是Gradle构建中处理文件时可能遇到的问题之一，幸运的是Gradle几乎为所有这种问题提供给了解决方案
	
# 4. 复制目录层次结构
当`from()`方法传入文件夹作为参数时 ，拷贝会包含文件和其文件结构

## 4.1 复制整个文件夹

	task copyReportsDirForArchiving(type: Copy) {
	    from "$buildDir/reports"
	    into "$buildDir/toArchive"
	}
	
	
## 4.2 复制整个文件夹(包括其自身)	
**复制过程的关键点是如何控制目录结构复制到目标文件夹中,默认情况下在复制文件夹时，并不会将文件夹自身也复制到目标文件夹中**	
	
- 通过添加 包含正则 即可将文件夹自身也添加到目标文件夹中
	
示例：	
	
	task copyReportsDirForArchiving2(type: Copy) {
	    from("$buildDir") {
	        include "reports/**"
	    }
	    into "$buildDir/toArchive"
	}	
	
- 这里将`include`直接应用到`from()`方法中，之前的`include`是添加到整个Task中	

	复制规范中这些不同级别的粒度使得处理各种需求更加的方便，例如出现多个`from()`时，将`include()` 添加到Task中，那么会对所有的`from()`生效，如果只想对单个`from()`生效，那么可以将`include()`添加到`from()`中

	[Using child specifications](https://docs.gradle.org/current/userguide/working_with_files.html#sub:using_child_copy_specifications)



# 5. 创建存档(zip,tar,etc)

Gradle认为打包文件至存档实际上就是一个复制任务将目的地指定成一个归档文件

- 这意味着创建存档和复制文件是相似的，创建存档可以使用复制所拥有的特性

每种类型的存档都有其对应的任务类型，最常用的是`Zip`,`Tar`和`Jar`,它们都共享`Copy`类型的大多数配置，包括过滤和重命名	


## 5.1 将目录归档为ZIP

	task packageDistribution(type: Zip) {
	    archiveFileName = "my-distribution.zip"
	    destinationDirectory = file("$buildDir/dist")
	
	    from "$buildDir/toArchive"
	}
	
- 注意这里并没有直接使用`into()`,而是使用使用`archiveFileName()`和`destinationDirectory()`方法分别指定了Zip名称和Zip的存储路径

	**通常情况下，并不需要调用`archiveFileName()`和`destinationDirectory()`方法，因为大多数项目应用`Base Plugin`,其为这些属性提供了一些惯例值**	
	
	
## 5.2 使用BasePlugin提供的归档名称惯例

最常见的场景之一是将文件复制到存档的指定子目录中
		
	plugins {
	    id 'base'
	}
	
	version = "1.0.0"
	
	task packageDistribution(type: Zip) {
	    from("$buildDir/toArchive") {
	        exclude "**/*.pdf"
	    }
	
	    from("$buildDir/toArchive") {
	        include "**/*.pdf"
	        into "docs"
	    }
	}	
	
- 上面的例子将所有`PDF`类型的文件拷贝到了归档文件的`docs`目录下，其余文件都在归档文件的根目录下

# 6. 解压归档

归档文件实际上是自包含的文件系统，因此解压它们就是将文件从归档文件系统复制到本地文件系统中(复制到另外一个归档文件中也是可以的) . Gradle通过提供一些包装函数来实现这一点，这些包装函数使得归档可以作为文件树来使用(hierarchical collections)

- **通过使用 `Project.zipTree(java.lang.Object)` 和`Project.tarTree(java.lang.Object)`方法，可以将归档文件转换成`FileTree`对象**

	**`FileTree`可以被用在`from()`规范中**
	
- 请注意并没有`jarTree()`方法,因为`zipTree()`方法可以完美的为`Jars,Wars,Ears`工作	

## 6.1 解压Zip文件

	task unpackFiles(type: Copy) {
	    from zipTree("src/resources/thirdPartyResources.zip")
	    into "$buildDir/resources"
	}
	
- 与普通的复制任务一样，可以通过控制过滤器决定解压哪些文件，以及在解压时重命名文件

## 6.2 解压Zip文件的子集

可以通过`eachFile()`方法来进行更高级的处理。例如，将归档所代表的`FileTree`的不同子树分别提取到目标目录的不同路径下

	task unpackLibsDirectory(type: Copy) {
	    from(zipTree("src/resources/thirdPartyResources.zip")) {
	        include "libs/**"  // (1)
	        eachFile { fcd ->
	            fcd.relativePath = new RelativePath(true, fcd.relativePath.segments.drop(1))  // (2)
	        }
	        includeEmptyDirs = false  // (3)
	    }
	    into "$buildDir/resources"
	}
	
- 三点注释:

	1. 仅提取归档文件中`libs`文件夹下的文件的子集

	2. 通过删除文件路径中的`libs`片段，将待提取文件的路径映射目标目录下	
	3. 忽略重新映射导致的空目录
	
# 7 创建“uber”/"fat" Jar

在Java中，应用程序以及其依赖通常分别被打包到各自的Jar包中。 现在还有另外一种方法，就是将依赖的类和资源直接打包到应用程序的Jar包中(这种被称作`uber`或`fat`Jar)

Gradle使得这种方法十分容易去实现，只需要使用`Project.zipTree(java.lang.Object)`方法和`Jar`任务即可

## 7.1 创建一个Java uber/fat Jar

	plugins {
	    id 'java'
	}
	
	version = '1.0.0'
	
	repositories {
	    mavenCentral()
	}
	
	dependencies {
	    implementation 'commons-io:commons-io:2.6'
	}
	
	task uberJar(type: Jar) {
	    archiveClassifier = 'uber'
	
	    from sourceSets.main.output
	
	    dependsOn configurations.runtimeClasspath
	    from {
	        configurations.runtimeClasspath.findAll { it.name.endsWith('jar') }.collect { zipTree(it) }
	    }
	}

- 在本例中，获取项目的`configuration.runtimeclasath.files`(运行时依赖项)，并使用`zipTree()`方法包装每个JAR文件。结果是一个ZIP文件树的集合，其内容连同应用程序的类一起复制到uber JAR中。


# 8. 创建文件夹

在任务中显示的定义文件或目录输出时，Gradle会自动管理任务的这一方面(自动生成文件或文件夹)，因为大多数的任务都需要为其所生成的内容提供一个目录去存储

- Gradle提供了`Project.mkdir(java.lang.Object)`方法以应用需要手动创建文件夹的需求，该方法在任务或构建脚本中都能使用

## 8.1 手动创建文件夹

	task ensureDirectory {
	    doLast {
	        mkdir "images"
	    }
	}

# 9. 移动文件或文件夹

Gradle并没有提供关于移动文件或文件夹的Api，但是可以通过`Apache Ant integration`去实现这一点


	task moveReports {
	    doLast {
	        ant.move file: "${buildDir}/reports",
	                 todir: "${buildDir}/toArchive"
	    }
	}

- 移动文件或文件夹可能导致破坏构建结构，因此更建议使用Copy


# 10. 在复制时修改文件名称

Gradle在复制规范中提供了`rename()`方法，这允许文件在复制过程中被重命名

	task copyFromStaging(type: Copy) {
	    from "src/main/webapp"
	    into "$buildDir/explodedWar"
	
	    rename '(.+)-staging(.+)', '$1$2'
	}

- `rename()`中可以使用正则表达式,或者可以使用一个闭包来使用更加复杂的规则去定义一个目标文件的名称


## 10.1 在复制时删除文件名

	task copyWithTruncate(type: Copy) {
	    from "$buildDir/reports"
	    rename { String filename ->
	        if (filename.size() > 10) {
	            return filename[0..7] + "~" + filename.size()
	        }
	        else return filename
	    }
	    into "$buildDir/toArchive"
	}

- 与过滤一样，可以将重命名配置到`from()`，使其作为文件子集规范的一部分，从而将重命名应用于文件子集


# 11. 删除文件和文件夹

Gradle提供了`Delete`任务类型或`Project.delete(org.gradle.api.Action)`方法来删除文件或文件夹

- 俩个方法都需要传入 `Project.files(java.lang.Object…​)`方法支持的文件或文件夹对象


## 11.1 删除一个文件夹

	task myClean(type: Delete) {
	    delete buildDir
	}

## 11.2 删除匹配规则的文件
如果想对被删除的文件进行过滤，必须得通过`FileCollection`或`FileTree`内置的方法


	task cleanTempFiles(type: Delete) {
	    delete fileTree("src").matching {
	        include "**/*.tmp"
	    }
	}
