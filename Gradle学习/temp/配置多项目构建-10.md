# 配置多项目构建

[Configuring Multi-Project Builds](https://docs.gradle.org/current/userguide/multi_project_builds.html)

# 1. 简介

对多项目构建的强大支持是Gradle独特的卖点之一

Gradle中的多项目构建由一个根项目和一个或多个子项目组成，这些子项目也可能有子项目

# 2. 跨项目配置

虽然每个子项目都可以在完全独立于其他子项目的情况下配置自己，但是子项目具有相同的特性是很常见的。针对这种情况，通常更可取的做法是在项目之间共享配置，这样相同的配置会影响多个子项目


Gradle的核心是一个通用的构建工具，因此项目不必是Java项目


## 2.1 配置和执行

[`Build phases`](https://docs.gradle.org/current/userguide/build_lifecycle.html#sec:build_phases)描述了每个构建的阶段，在这里，主要关注多项目构建的配置和执行阶段

- `Configuration`阶段意味着执行项目的`build.gradle`文件，这意味着下载所有使用`apply`语句或`plugins`块声明的插件。默认情况下，所有对项目的配置都发生在任何任务执行之前。这意味着在多项目中执行单个项目的单个任务时，会先去配置多项目构建的所有项目

	每个项目都需要进行配置的原因是为了支持去访问或修改Gradle项目模型的任何部分
	
## 2.2 按需配置

因为每个项目都在执行阶段之前配置，因此可以实现配置注入功能和对完整项目模型的访问 然而，在非常大的多项目构建中，这种方法可能不是最有效的。当Gradle构建具有数百个子项目的层次结构，其配置阶段将非常耗时，因此`scalability`是Gradle的重要要求

- 从版本1.4开始，引入了一种新的孵化模式 按需配置(`configuration on demand`)。

按需配置模式尝试只配置与请求任务相关的项目，即只执行参与构建的项目中的`build.gradle`文件。这样，可以减少大型多项目构建的配置时间。从长远来看，这种模式将成为默认模式，可能是Gradle构建执行的唯一模式

- 按需配置特性正在孵化中，因此不能保证每个构建都能正确工作。该特性对于已解耦项目的多项目构建应该非常有效

在按需配置模式中，项目按照如下规则进行配置:

- **根项目总是会被配置**。这种行为支持了通用配置(`allprojects`或`subprojects`脚本块)

- **执行构建的目录中的项目也会被配置**，但仅在没有指定任何task的去执行Gradle命令时。 这样，在按需配置项目时，默认任务才会正常运行

- **标准的项目依赖关系会导致配置相关的项目**。即如果项目A对项目B具有编译依赖关系，那么构建A将导致对两个项目的配置

- **通过任务路径声明的任务依赖项会导致配置相关的项目**。举例`someTask.dependsOn(":someOtherProject:someOtherTask")`

- **通过命令行（或Tooling API）执行指定任务路径下的任务会导致配置相关项目**。 例如，构建`projectA：projectB：someTask`会导致projectB的配置


如果想要设置所有的构建都进行按需配置，查看[Gradle properties](https://docs.gradle.org/current/userguide/build_environment.html#sec:gradle_configuration_properties)
	
如果仅仅针对个别构建进行按需配置，查看[command-line performance-oriented options](https://docs.gradle.org/current/userguide/command_line_interface.html#sec:command_line_performance)


## 2.3 定义跨项目的通用行为

Gradle主要有俩种方式去定义跨项目的通用行为:

1. **`Project API`提供了一个属性`allprojects`和`allprojects()`方法。前者返回一个列表，其中包含了当前项目及其下的所有子项目 。 后者可以接受一个闭包作为参数，项目对象将传给闭包作为其代理**

2. **共享配置的另外一种方法就是使用公共外部脚本**

下面介绍一个多项目构建，其中`water`是其根项目，`bluewhale`是其子项目

这个示例可以在发行版的`samples/userguide/multiproject/firstExample/water`目录下找到

### 2.3.1 多项目树 - water&bluewhale

	// 项目布局
	.
	├── bluewhale/
	├── build.gradle
	└── settings.gradle

	// settings.gradle
	rootProject.name = 'water'
	include 'bluewhale'

- `bluewhale`项目的构建脚本在哪里？

	在Gradle中，构建脚本是可选的。对于单项目构建来说，项目如果没有构建脚本是没有意义的。但是对于多项目构建来说，情况就不同了
	
	
### 2.3.2 构建water项目

	// build.gradle
	Closure cl = { task -> println "I'm $task.project.name" }
	task('hello').doLast(cl)
	project(':bluewhale') {
	    task('hello').doLast(cl)
	}	
		
	> gradle -q hello
	I'm water
	I'm bluewhale
	
- Gradle允许从任何构建脚本中去访问多项目构建的任何项目。Project API提供了一个名为`project()`的方法，该方法接受一个路径作为参数，并返回该路径的项目对象

	**Gradle将这种从任意构建脚本中对任意项目进行配置的行为成为 跨项目构建**,这是Gradle借助配置注入(`configuration injection`)实现的
	
	
- 这种显示为各个项目添加任务的行为并不方便，可以通过其他的方式更加方便的实现

### 2.3.3 添加一个krill子项目

	// 项目布局
	.
	├── bluewhale/
	├── build.gradle
	├── krill/
	└── settings.gradle


	// settings.gradle
	rootProject.name = 'water'
	
	include 'bluewhale', 'krill'
	
下面重写water项目的构建脚本，将其对所有项目添加`hello`任务的逻辑进行简化

	//build.gradle
	allprojects {
	    task hello {
	        doLast { task ->
	            println "I'm $task.project.name"
	        }
	    }
	}	
	
	
	> gradle -q hello
	I'm water
	I'm bluewhale
	I'm krill
	

-  如果将闭包作为参数调用`allprojects()`方法，则闭包的语句将委托给与`allprojects`关联的项目。 此外，还可以通过`allprojects.each`（在Groovy中）进行迭代
	
	
**其他构建系统使用继承作为定义通用行为的主要手段。 Gradle同样为项目提供继承，稍后您将看到。但Gradle默认使用配置注入去定义通用行为**
	


# 3. 子项目配置

Project PI还提供了一个仅用于访问子项目的属性

## 3.1 定义所有子项目的通用行为

	// build.gradle
	allprojects {
	    task hello {
	        doLast { task ->
	            println "I'm $task.project.name"
	        }
	    }
	}
	subprojects {
	    hello {
	        doLast {
	            println "- I depend on water"
	        }
	    }
	}
	
	> gradle -q hello
	I'm water
	I'm bluewhale
	- I depend on water
	I'm krill
	- I depend on water
	
- 上面例子中，有两个代码片段引用了“hello”任务

	1. 第一个代码片段中，使用“task”关键字（在Groovy中）构造了任务，并提供了基本配置
	
	2. 第二个代码片段中，不需要使用“task”关键字，因为这里只是进一步配置了现有的“hello”任务

	任务只能在项目中被构造一次，但可以添加任意数量代码块为其提供配置
	
	
## 3.2 添加特定的行为

Gradle允许在公共行为上添加特定的行为。通常情况下，会将项目的特定行为放在项目的构建脚本中，这个构建脚本会应用该特定行为。但是Gradle提供了其他方式去实现 

### 3.2.1 为特定项目添加特定行为

	// build.gradle
	allprojects {
	    task hello {
	        doLast { task ->
	            println "I'm $task.project.name"
	        }
	    }
	}
	subprojects {
	    hello {
	        doLast {
	            println "- I depend on water"
	        }
	    }
	}
	project(':bluewhale').hello {
	    doLast {
	        println "- I'm the largest animal that has ever lived on this planet."
	    }
	}	
	
	
	> gradle -q hello
	I'm water
	I'm bluewhale
	- I depend on water
	- I'm the largest animal that has ever lived on this planet.
	I'm krill
	- I depend on water

### 3.2.2 为krill项目添加特定行为

**通常更喜欢将项目的特定行为放入对应项目的构建脚本中。这里对krill项目进行重构并添加一些特定于项目的行为**

	// 项目布局
	.
	├── bluewhale
	│   └── build.gradle
	├── build.gradle
	├── krill
	│   └── build.gradle
	└── settings.gradle
	
	
	// settings.gradle
	rootProject.name = 'water'
	include 'bluewhale', 'krill'	
		
	// bluewhale/build.gradle
	hello.doLast {
	  println "- I'm the largest animal that has ever lived on this planet."
	}	
	
	// krill/build.gradle
	hello.doLast {
	  println "- The weight of my species in summer is twice as heavy as all human beings."
	}	
		
	
	// 根项目的build.gradle
	allprojects {
	    task hello {
	        doLast { task ->
	            println "I'm $task.project.name"
	        }
	    }
	}
	subprojects {
	    hello {
	        doLast {
	            println "- I depend on water"
	        }
	    }
	}
	
	
	> gradle -q hello
	I'm water
	I'm bluewhale
	- I depend on water
	- I'm the largest animal that has ever lived on this planet.
	I'm krill
	- I depend on water
	- The weight of my species in summer is twice as heavy as all human beings.
	
	
# 4. 过滤项目

为了展示配置注入的更多功能，添加另一个名为`tropicalFish`的项目，并通过`water`项目的构建脚本添加更多的行为到构建中


## 4.1 通过名称过滤

给特定的项目添加自定义行为(通过项目名称进行过滤)

	// 项目布局
	.
	├── bluewhale/
	│   └── build.gradle
	├── build.gradle
	├── krill/
	│   └── build.gradle
	├── settings.gradle
	└── tropicalFish/

	// settings.gradle
	rootProject.name = 'water'
	include 'bluewhale', 'krill', 'tropicalFish'
	
	// build.gradle
	allprojects {
	    task hello {
	        doLast { task ->
	            println "I'm $task.project.name"
	        }
	    }
	}
	subprojects {
	    hello {
	        doLast {
	            println "- I depend on water"
	        }
	    }
	}
	configure(subprojects.findAll {it.name != 'tropicalFish'}) {
	    hello {
	        doLast {
	            println '- I love to spend time in the arctic waters.'
	        }
	    }
	}	
	
	> gradle -q hello
	I'm water
	I'm bluewhale
	- I depend on water
	- I love to spend time in the arctic waters.
	- I'm the largest animal that has ever lived on this planet.
	I'm krill
	- I depend on water
	- I love to spend time in the arctic waters.
	- The weight of my species in summer is twice as heavy as all human beings.
	I'm tropicalFish
	- I depend on water	

- **`configure()`方法接受列表作为参数，并将配置应用于列表中的项目**

## 4.2 通过属性过滤

除了使用项目名称进行过滤，还可以通过属性进行过滤，筛选出特定项目

	// 项目布局
	.
	├── bluewhale
	│   └── build.gradle
	├── build.gradle
	├── krill
	│   └── build.gradle
	├── settings.gradle
	└── tropicalFish
	    └── build.gradle
	
	// settings.gradle
	rootProject.name = 'water'
	include 'bluewhale', 'krill', 'tropicalFish'
	
	// bluewhale/build.gradle
	ext.arctic = true
	hello.doLast {
	  println "- I'm the largest animal that has ever lived on this planet."
	}
		
	// krill/build.gradle
	ext.arctic = true
	hello.doLast {
	    println "- The weight of my species in summer is twice as heavy as all human beings."
	}
	

	// build.gradle
	allprojects {
	    task hello {
	        doLast { task ->
	            println "I'm $task.project.name"
	        }
	    }
	}
	subprojects {
	    hello {
	        doLast {println "- I depend on water"}
	    }
	
	    afterEvaluate { Project project ->
	        if (project.arctic) {
	            hello.configure {
	                doLast {
	                    println '- I love to spend time in the arctic waters.'
	                }
	            }
	        }
	    }
	}	
		
	// tropicalFish/build.gradle
	ext.arctic = false
	
	
	> gradle -q hello
	I'm water
	I'm bluewhale
	- I depend on water
	- I'm the largest animal that has ever lived on this planet.
	- I love to spend time in the arctic waters.
	I'm krill
	- I depend on water
	- The weight of my species in summer is twice as heavy as all human beings.
	- I love to spend time in the arctic waters.
	I'm tropicalFish
	- I depend on water	
	
- 在`water`项目的构建文件中，使用了`afterEvaluate`通知。这意味着在子项目的构建脚本被评估之后，才会对所传递的闭包进行评估。这是因为`arctic`属性在每个构建脚本中设置，所以必须使用这种方式。


# 5. 多项目构建的执行规则

当在根项目目录下执行`hello`任务时，所有的项目的`hello`任务都会被执行

## 5.1 在子项目目录执行任务

下面将执行目录切换到`bluewhale`项目下，看看会发生什么?

	> gradle -q hello
	I'm bluewhale
	- I depend on water
	- I'm the largest animal that has ever lived on this planet.
	- I love to spend time in the arctic waters.

	
Gradle行为背后的基本规则很简单。Gradle从当前目录开始,按照层级结构向下查找名称为hello的任务，并执行它们

- 有一件事需要注意。Gradle总是评估多项目构建的每个项目，并创建所有现有的任务对象。然后，根据任务名称参数和当前目录，Gradle筛选应该执行的任务。由于跨项目配置，每个项目在执行任何任务之前都必须进行评估

### 5.1.1 评估并执行项目

	// bluewhale/build.gradle
	ext.arctic = true
	hello {
	    doLast {
	        println "- I'm the largest animal that has ever lived on this planet."
	    }
	}
	
	task distanceToIceberg {
	    doLast {
	        println '20 nautical miles'
	    }
	}

	// krill/build.gradle
	ext.arctic = true
	hello {
	    doLast {
	        println "- The weight of my species in summer is twice as heavy as all human beings."
	    }
	}
	
	task distanceToIceberg {
	    doLast {
	        println '5 nautical miles'
	    }
	}

	// 带-q选项的输出
	> gradle -q distanceToIceberg
	20 nautical miles
	5 nautical miles
	// 不带-q选项的输出
	> gradle distanceToIceberg
	
	> Task :bluewhale:distanceToIceberg
	20 nautical miles
	
	> Task :krill:distanceToIceberg
	5 nautical miles

- 当前构建在`water`项目目录下执行.Gradle并不关心 `water`和`tropicalFish`哪个项目拥有一个名为`distanceToIceberg`的任务，只要执行层次结构中具有此名称的所有任务就行，只有在没有此名称的任务时才会抛出问题

