# 面向对象

[Object Orientation](http://www.groovy-lang.org/objectorientation.html)


# 1. 类型

## 1.1 原始类型

Groovy支持Java语言标准的原始类型

- 整数类型:`byte`(8 bit), `short` (16 bit), `int` (32 bit) 和 `long`(64 bit)

- 浮点类型: `float` (32 bit) and `double` (64 bit)

- 布尔类型:`boolean`(`true`/`false`)

- 字符类型:`char`(16 bit),可用作数字类型，表示UTF-16编码


当Groovy声明字段或变量为原始类型时，它会被会自动包装对基本类型的引用(因为Groovy中的一切都是对象)

### 1.1.1 原始类型的包装类

Primitive type	|Wrapper class
:---:|:---:
boolean|Boolean
char|Character
short|Short
int|Integer
long|Long
float|Float
double|Double

示例(使用`int`)

	class Foo {
	  static int i
	}
	
	assert Foo.class.getDeclaredField('i').type == int.class
	assert Foo.i.class != int.class && Foo.i.class == Integer.class

- 实际上，Groovy使用运算符时不会每次都进行拆箱和装箱，因为Groovy会将操作符编译成对应的方法调用

- 此外Groovy在调用一个接收原始类型参数的Java方法时会自动将参数拆箱为原始类型，同时会自动对原始类型的返回值进行装箱

## 1.2 类

Groovy类与Java类相似，并且与JVM级别的Java类兼容

- Groovy类可以拥有方法，字段和属性

- **类和类的成员可以拥有与Java相同的修饰符(`public`,`protected`,`private`,`static`等),不过还是会有一些区别**


Groovy类与Java类的主要区别:

- **Groovy的类或方法如果没有显示的声明修饰符，那么默认的是`public`(Groovy提供了一个特殊的注解来实现包可见性)**

- **Groovy的字段如果没有显示的声明修饰符，那么默认会被当做属性处理**

- **Groovy类的名称可以与源文件的文件的名称不相同**

- **Groovy的一个源文件可以保存多个类，但是如果存在一些代码不在类中，那么该源文件可能会被认为是一个脚本**

	**脚本仅仅是具有特殊约定的类，并且与源文件拥有相同的名称(因此，不要在脚本中定义与源文件拥有相同名称的类，这会导致冲突)**
	
	
	
示例：

	class Person {                       
	
	    String name                      
	    Integer age
	
	    def increaseAge(Integer years) { 
	        this.age += years
	    }
	}


### 1.2.1 普通类(`Normal class`)

普通类指的是顶层的并且有具体实现的类。 这意味着它们可以在没有任何其他类或脚本限制的情况下实例化。 因此，它们只能是公共的（即使可以抑制public关键字）

- **类通过使用new关键字调用其构造函数来实例化类**

		def p = new Person()

### 1.2.2 内部类(`Inner class`)

**内部类指的是定义在另外一个类内部的类**

- **外部类可以直接使用内部类，而内部类可以访问外部类中的成员(即使成员是私有的)**

- **除了外部类之外的类不允许访问内部类**

示例：

	class Outer {
	    private String privateStr
	
	    def callInnerMethod() {
	        new Inner().methodA()       
	    }
	
	    class Inner {                   
	        def methodA() {
	            println "${privateStr}." 
	        }
	    }
	}

使用内部类的几种原因:

- 内部类无法被其他类直接访问(除了直接的外部类),这将增加封装性

- 将一组指定的内部类添加到同一个外部类中将提供良好的代码结构

- 仅在使用内部类的地方定义内部类，易于维护代码


**在某种情况下，内部类是接口的实现，并且需要提供给外部类使用**

	class Outer2 {
	    private String privateStr = 'some string'
	
	    def startThread() {
	       new Thread(new Inner2()).start()
	    }
	
	    class Inner2 implements Runnable {
	        void run() {
	            println "${privateStr}."
	        }
	    }
	}

- 定义`Inner2`内部类仅仅是为了提供外部类中`Thread`类所需的参数的实现，其实可以使用匿名内部类来消除这种代码冗余

		class Outer3 {
		    private String privateStr = 'some string'
		
		    def startThread() {
		        new Thread(new Runnable() {      
		            void run() {
		                println "${privateStr}."
		            }
		        }).start()                       
		    }
		}
		
	- 使用匿名内部类完全可以替换掉那种仅使用了一次的内部类


### 1.2.3 抽象类

抽象类表示通用概念，因此，它们无法实例化。 抽象类的成员包括字段/属性和抽象或具体方法。 抽象方法没有具体实现，必须由子类去实现

	abstract class Abstract {         
	    String name
	
	    abstract def abstractMethod() 
	
	    def concreteMethod() {
	        println 'concrete'
	    }
	}

- 抽象类/方法必须使用`abstract`关键字声明

抽象类与接口的区别:

1. 抽象类可以拥有字段/属性，以及拥有具体实现的方法，但是接口只能拥有抽象方法

2. 同一个类只能继承一个抽象类，但是能实现多个接口

## 1.3 接口

接口定义了类需要遵循的约定，其仅定义了一组需要被实现的方法，但是不提供方法的具体实现
	
	interface Greeter {                                         
	    void greet(String name)                                 
	}

接口中的方法必须是`public`,如果使用`protected`或`private`等修饰符进行修饰，则会报错

如果在类的`implements`列表中或父类中定义了接口，那么就表示该类实现了这个接口

	class SystemGreeter implements Greeter {                    
	    void greet(String name) {                               
	        println "Hello $name"
	    }
	}
	
	def greeter = new SystemGreeter()
	assert greeter instanceof Greeter  
	
	
对于一个与接口拥有相同方法的类来说，并且该类没有实现接口， Groovy允许通过`as`强转操作符在运行时将其转成接口类型

	class DefaultGreeter {
	    void greet(String name) { println "Hello" }
	}
	greeter = new DefaultGreeter()    
	assert !(greeter instanceof Greeter)                          
	coerced = greeter as Greeter                                
	assert coerced instanceof Greeter
	
- `greeter `对象并没有实现接口，`coerced`对象代理了`greeter`对象

## 1.4 构造函数

**构造函数是用于初始化具有特定状态的对象的特殊方法**

- 与普通方法一样，只要每个构造函数具有唯一的类型签名，类就可以声明多个构造函数

- 如果没有手动提供空参数的构造函数，Groovy编译器将提供一个


Groovy支持俩种形式的构造函数调用

1. 使用位置参数调用构造函数

2. 使用命名参数调用构造函数(允许在调用构造函数时设置指定名称的参数)

### 1.4.1 位置参数(`Positional parameters`)

使用位置参数来创建构建，那么对应的类中就要存在一个或多个构造函数，并且每个构造函数的类型签名必须唯一

**通常情况下，如果声明了至少一个构造函数，那么类就只能通过这些构造函数来实例化,这种情况下无法使用命名参数进行实例化**

使用位置参数调用构造函数有三种形式:

1. 使用`new`关键字

2. 使用`as`关键字进行强转

3. 在赋值时进行强转


示例：

	class PersonConstructor {
	    String name
	    Integer age
	
	    PersonConstructor(name, age) {          
	        this.name = name
	        this.age = age
	    }
	}
	
	def person1 = new PersonConstructor('Marie', 1)  
	def person2 = ['Marie', 2] as PersonConstructor  
	PersonConstructor person3 = ['Marie', 3]


### 1.4.2 命名参数(`Named parameters`)

**Groovy仅在三种情况下可以使用命名参数的形式来实例化**

1. 类包含一个无参构造函数(或者类没有构造函数)

2. 类包含一个仅接受`Map`类型参数的构造函数(需要在构造函数中对变量赋值)

3. 类包含一个首参数为`Map`类型的多参数构造函数(需要在构造函数中对变量赋值)


示例：

	class PersonWOConstructor {                                  
	    String name
	    Integer age
	}
	
	def person4 = new PersonWOConstructor()                      
	def person5 = new PersonWOConstructor(name: 'Marie')         
	def person6 = new PersonWOConstructor(age: 1)                
	def person7 = new PersonWOConstructor(name: 'Marie', age: 2)
	
	
**注意:**	

1. 如果类拥有无参构造函数或无构造函数， 使用命名参数形式调用构造函数去创建对象时，Groovy会自动调用每个参数对应的`setter`

2. 如果类的构造函数为`Map`类型，并且仅有一个参数(或者拥有多个参数，但是第一个参数类型为`Map`),那么在使用命名参数形式调用构造函数去创建对象时，需要手动在构造函数中对属性进行设置

3. 可以通过同时提供无参构造函数和带位置参数的构造函数来同时支持俩种形式的构造函数调用


## 1.5 方法

### 1.5.1 方法的定义

方法可以定义返回值类型，或者通过`def`关键字来使得返回值没有指定类型

- 方法可以接收任意个数参数，并且参数类型可以未指定

- Groovy中的方法可以使用Java的修饰符，如果没有提供修饰符，那么默认方法就是`public`

Groovy中的方法总是会返回值

- 如果没有使用`return`关键字指定返回值，那么方法的最后一行计算出的值会被返回

		def someMethod() { 'method called' }                           
		String anotherMethod() { 'another method called' }             
		def thirdMethod(param1) { "$param1 passed" }                   
		static String fourthMethod(String param1) { "$param1 passed" }
		
		
		
### 1.5.2 命名参数

	

## 1.6 字段和属性


## 1.7 注解


## 1.8 继承

## 1.9 泛型


# 2. 特征

## 2.1 方法

## 2.2 this的含义