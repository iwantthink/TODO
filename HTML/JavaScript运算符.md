# JavaScript运算符

[JavaScript运算符-阮一峰](https://wangdoc.com/javascript/operators/index.html)

# 1. 算术运算符

运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。


运算符	|描述	|例子	|结果
---|---|---|---
+	|加	|x=y+2	|x=7
-	|减	|x=y-2	|x=3
*	|乘	|x=y*2	|x=10
/	|除	|x=y/2	|x=2.5
`**`  |指数|x=y`**`2 | x= 25
%	|求余数 (保留整数)	|x=y%2	|x=1
++	|自减	|x=++y	|x=6
--	|自增	|x=--y	|x=4
+|数值运算符|+y| 5
-|负数值运算符|-y| -5

## 1.1  加法运算符

加法运算符（+）是最常见的运算符，用来求两个数值的和。

- JavaScript 允许非数值的相加。

		true + true // 2
		1 + true // 2

	- 布尔值都会自动转成数值，然后再相加

- 如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起

- 如果一个运算项是字符串，另一个运算项是非字符串，这时非字符串会转成字符串，再连接在一起。

	- 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算项的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。

**除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。**


## 1.1.1 对象的相加

如果运算项是对象，必须先转成原始类型的值，然后再相加。

	var obj = { p: 1 };
	obj + 2 // "[object Object]2"

- 对象转成原始类型的值，规则如下:

	1. 首先，自动调用对象的`valueOf`方法。

			var obj = { p: 1 };
			obj.valueOf() // { p: 1 }

	2. 一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。

			var obj = { p: 1 };
			obj.valueOf().toString() // "[object Object]"
	
	3. 对象的toString方法默认返回[object Object]，所以就得到了最前面那个例子的结果。知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。

			var obj = {
			  valueOf: function () {
			    return 1;
			  }
			};
			
			obj + 2 // 3

	- 如果通过valueof 获取到的值是字符串,那么 加法运算符就变成了 连接运算符

			var obj = {
			  toString: function () {
			    return 'hello';
			  }
			};
			
			obj + 2 // "hello2"

	- 这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。

			var obj = new Date();
			obj.valueOf = function () { return 1 };
			obj.toString = function () { return 'hello' };
			
			obj + 2 // "hello2"

## 1.2 余数运算符

余数运算符（%）返回前一个运算项被后一个运算项除，所得的余数。

- 需要注意的是，运算结果的正负号由第一个运算项的正负号决定。

	所以，为了得到负数的正确余数值，**可以先使用绝对值函数**。

- 余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。

## 1.3 自增和自减运算符

自增和自减运算符，是一元运算符，只需要一个运算子。

- 它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。

- 运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

- 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

## 1.4 数值运算符,负数运算符

数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。

数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。

	+true // 1
	+[] // 0
	+{} // NaN

- 上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行NaN也是数值）。具体的类型转换规则


负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。
	
	var x = 1;
	-x // -1
	-(-x) // 1


**数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。**

## 1.5 指数运算符

指数运算符（**）完成指数运算，前一个运算子是底数，后一个运算子是指数。

- **指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算**。

		// 相当于 2 ** (3 ** 2)
		2 ** 3 ** 2
		// 512


## 1.6 赋值运算符

赋值运算符（Assignment Operators）用于给变量赋值。

- 最常见的赋值运算符，当然就是等号（=）。

赋值运算符和算术运算符结合:

	// 等同于 x = x + y
	x += y
	
	// 等同于 x = x - y
	x -= y
	
	// 等同于 x = x * y
	x *= y
	
	// 等同于 x = x / y
	x /= y
	
	// 等同于 x = x % y
	x %= y
	
	// 等同于 x = x ** y
	x **= y

赋值运算符和位运算符结合

	// 等同于 x = x >> y
	x >>= y
	
	// 等同于 x = x << y
	x <<= y
	
	// 等同于 x = x >>> y
	x >>>= y
	
	// 等同于 x = x & y
	x &= y
	
	// 等同于 x = x | y
	x |= y
	
	// 等同于 x = x ^ y
	x ^= y

**这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。**



# 2. 比较运算符

比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。


运算符	|描述	|例子
---|---|---
==	|相等运算符	|x==8 为 false
===	|严格相等运算符（值和类型）	| x===5 为 true；x==="5" 为 false
!=	|不相等运算符	|x!=8 为 true
>	|大于运算符	|x>8 为 false
<	|小于运算符	|x<8 为 true
>=	|大于或等于运算符	|x>=8 为 false
<=	|小于或等于运算符	|x<=8 为 true
!== |严格不相等运算符 |x!=='5' 为true

这八个比较运算符分成两类：

- 相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

## 2.1 非相等运算符：字符串之间的比较

字符串按照字典顺序进行比较。

	'cat' > 'dog' // false
	'cat' > 'catalog' // false

- JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。

		'cat' > 'Cat' // true'

	- 上面代码中，小写的c的 Unicode 码点（99）大于大写的C的 Unicode 码点（67），所以返回true。

- 由于所有字符都有 Unicode 码点，因此汉字也可以比较。


## 2.2 非相等运算符：非字符串的比较

如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

1. 原始类型值

	如果两个运算子都是原始类型(数值,字符串,布尔值)的值，则是先转成数值再比较。

			5 > '4' // true
			// 等同于 5 > Number('4')
			// 即 5 > 4
			
			true > false // true
			// 等同于 Number(true) > Number(false)
			// 即 1 > 0
			
			2 > true // true
			// 等同于 2 > Number(true)
			// 即 2 > 1

	- 这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false。

2. 对象

	如果运算子存在一个是对象，会转为原始类型的值，再进行比较。

		var x = [2];
		x > '11' // true
		// 等同于 [2].valueOf().toString() > '11'
		// 即 '2' > '11'
		
		x.valueOf = function () { return '1' };
		x > '11' // false
		// 等同于 [2].valueOf() > '11'
		// 即 '1' > '11'

	- 两个对象之间的比较也是如此。

			[2] > [1] // true
			// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
			// 即 '2' > '1'
			
			[2] > [11] // true
			// 等同于 [2].valueOf().toString() > [11].valueOf().toString()
			// 即 '2' > '11'
			
			{ x: 2 } >= { x: 1 } // true
			// 等同于 { x: 2 }.valueOf().toString() >= { x: 1 }.valueOf().toString()
			// 即 '[object Object]' >= '[object Object]'


## 2.3 严格相等运算符

JavaScript 提供两种相等运算符：==和===。

- 简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。

### 2.3.1 不同类型的值

如果两个值的类型不同，直接返回false。

	1 === "1" // false
	true === "true" // false

### 2.3.2 同一类的原始类型值

同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。

	1 === 0x1 // true

- 上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回true。

- 需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。

### 2.3.3 复合类型值

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。

	{} === {} // false
	[] === [] // false
	(function () {} === function () {}) // false

- 上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。

	原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。

如果两个变量引用同一个对象，则它们相等。

	var v1 = {};
	var v2 = v1;
	v1 === v2 // true

- 对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。

		var obj1 = {};
		var obj2 = {};
		
		obj1 > obj2 // false
		obj1 < obj2 // false
		obj1 === obj2 // false

	- 上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回false。



### 2.3.4 undefined和null

undefined和null与自身严格相等。

	undefined === undefined // true
	null === null // true

由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。

	var v1;
	var v2;
	v1 === v2 // true

## 2.4 严格不相等运算符

严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。

	1 !== '1' // true
	// 等同于
	!(1 === '1')

## 2.5 相等运算符

相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。

	1 == 1.0
	// 等同于
	1 === 1.0

比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成四种情况，讨论不同类型的值互相比较的规则。

### 2.5.1 原始类型值

原始类型的值会转换成数值再进行比较。
	
	1 == true // true
	// 等同于 1 === Number(true)
	
	0 == false // true
	// 等同于 0 === Number(false)
	
	2 == true // false
	// 等同于 2 === Number(true)
	
	2 == false // false
	// 等同于 2 === Number(false)
	
	'true' == true // false
	// 等同于 Number('true') === Number(true)
	// 等同于 NaN === 1
	
	'' == 0 // true
	// 等同于 Number('') === 0
	// 等同于 0 === 0
	
	'' == false  // true
	// 等同于 Number('') === Number(false)
	// 等同于 0 === 0
	
	'1' == true  // true
	// 等同于 Number('1') === Number(true)
	// 等同于 1 === 1
	
	'\n  123  \t' == 123 // true
	// 因为字符串转为数字时，省略前置和后置的空格

上面代码将字符串和布尔值都转为数值，然后再进行比较。

### 2.5.2 对象与原始类型值比较

对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。

	// 对象与数值比较时，对象转为数值
	[1] == 1 // true
	// 等同于 Number([1]) == 1
	
	// 对象与字符串比较时，对象转为字符串
	[1] == '1' // true
	// 等同于 String([1]) == '1'
	[1, 2] == '1,2' // true
	// 等同于 String([1, 2]) == '1,2'
	
	// 对象与布尔值比较时，两边都转为数值
	[1] == true // true
	// 等同于 Number([1]) == Number(true)
	[2] == true // false
	// 等同于 Number([2]) == Number(true)

- 数组[1]与数值进行比较，会先转成数值，再进行比较；与字符串进行比较，会先转成字符串，再进行比较；与布尔值进行比较，对象和布尔值都会先转成数值，再进行比较。

### 2.5.3 undefined 和 null

undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。

	false == null // false
	false == undefined // false
	
	0 == null // false
	0 == undefined // false
	
	undefined == null // true

### 2.5.4 相等运算符的缺点

相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

	0 == ''             // true
	0 == '0'            // true
	
	2 == true           // false
	2 == false          // false
	
	false == 'false'    // false
	false == '0'        // true
	
	false == undefined  // false
	false == null       // false
	null == undefined   // true
	
	' \t\r\n ' == 0     // true

- 上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。

## 2.6 不相等运算符

相等运算符有一个对应的“不相等运算符”（!=），它的算法就是先求相等运算符的结果，然后返回相反值。

	1 != '1' // false
	
	// 等同于
	!(1 == '1')


# 3. 布尔运算符


# 4. 二进制位运算符

# 5. 其他运算符,运算顺序













# 11. JS 运算符

## 11.1 比较运算符

比较运算符在逻辑语句中使用，以测定变量或值是否相等。




- 可以在条件语句中使用比较运算符对值进行比较，然后根据结果来采取行动

		if (age<18) document.write("Too young");

## 11.2 逻辑运算符

逻辑运算符用于测定变量或值之间的逻辑。


运算符	|描述	|例子
---|---|---
&&	|and|	(x < 10 && y > 1) 为 true
||	|or|	(x==5 || y==5) 为 false
!	|not|	!(x==y) 为 true






# 10. 运算符

运算符 = 用于赋值。

运算符 + 用于加值。


## 10.1 JavaScript 算术运算符




## 10.2 用于字符串的 + 运算符

+ 运算符用于把文本值或字符串变量加起来（连接起来）。

如需把两个或多个字符串变量连接起来，请使用 + 运算符。

	txt1="What a very";
	txt2="nice day";
	txt3=txt1+txt2;

**如果把数字与字符串相加，结果将成为字符串**。



# 15. JS错误

## 15.1 Try...Catch语句

try 语句捕捉代码块的错误。

- 允许我们定义在执行时进行错误测试的代码块

catch 语句处理错误。

- 允许我们定义当 try 代码块发生错误时，所执行的代码块

-  **try 和 catch 是成对出现的**


	try
	  {
	  //在这里运行代码
	  }
	catch(err)
	  {
	  //在这里处理错误
	  }

## 15.2 Throw语句

throw 语句创建或抛出异常（exception）

- 异常可以是 JavaScript 字符串、数字、逻辑值或对象


	try
	  {
		  var x=document.getElementById("demo").value;
		  if(x=="")    throw "empty";
		  if(isNaN(x)) throw "not a number";
		  if(x>10)     throw "too high";
		  if(x<5)      throw "too low";
	  }
	catch(err)
	  {
		  var y=document.getElementById("mess");
		  y.innerHTML="Error: " + err + ".";
	  }


# 16. JS 表单验证

JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证。

被 JavaScript 验证的这些典型的表单数据有：

- 用户是否已填写表单中的必填项目？

- 用户输入的邮件地址是否合法？

- 用户是否已输入合法的日期？

- 用户是否在数据域 (numeric field) 中输入了文本？