# JavaScript运算符

[JavaScript运算符-阮一峰](https://wangdoc.com/javascript/operators/index.html)

[Mozilla Web开发技术教程](https://developer.mozilla.org/zh-CN/docs/Web)

[原码,反码,补码 详细介绍](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

# 1. 算术运算符

运算符是处理数据的基本方法，用来从现有的值得到新的值。JavaScript 提供了多种运算符，覆盖了所有主要的运算。


运算符	|描述	|例子	|结果
---|---|---|---
+	|加	|x=y+2	|x=7
-	|减	|x=y-2	|x=3
*	|乘	|x=y*2	|x=10
/	|除	|x=y/2	|x=2.5
`**`  |指数|x=y`**`2 | x= 25
%	|求余数 (保留整数)	|x=y%2	|x=1
++	|自减	|x=++y	|x=6
--	|自增	|x=--y	|x=4
+|数值运算符|+y| 5
-|负数值运算符|-y| -5

## 1.1  加法运算符

加法运算符（+）是最常见的运算符，用来求两个数值的和。

- JavaScript 允许非数值的相加。

		true + true // 2
		1 + true // 2

	- 布尔值都会自动转成数值，然后再相加

- 如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起

- 如果一个运算项是字符串，另一个运算项是非字符串，这时非字符串会转成字符串，再连接在一起。

	- 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算项的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。

**除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。**


## 1.1.1 对象的相加

如果运算项是对象，必须先转成原始类型的值，然后再相加。

	var obj = { p: 1 };
	obj + 2 // "[object Object]2"

- 对象转成原始类型的值，规则如下:

	1. 首先，自动调用对象的`valueOf`方法。

			var obj = { p: 1 };
			obj.valueOf() // { p: 1 }

	2. 一般来说，对象的valueOf方法总是返回对象自身，这时再自动调用对象的toString方法，将其转为字符串。

			var obj = { p: 1 };
			obj.valueOf().toString() // "[object Object]"
	
	3. 对象的toString方法默认返回[object Object]，所以就得到了最前面那个例子的结果。知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。

			var obj = {
			  valueOf: function () {
			    return 1;
			  }
			};
			
			obj + 2 // 3

	- 如果通过valueof 获取到的值是字符串,那么 加法运算符就变成了 连接运算符

			var obj = {
			  toString: function () {
			    return 'hello';
			  }
			};
			
			obj + 2 // "hello2"

	- 这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。

			var obj = new Date();
			obj.valueOf = function () { return 1 };
			obj.toString = function () { return 'hello' };
			
			obj + 2 // "hello2"

## 1.2 余数运算符

余数运算符（%）返回前一个运算项被后一个运算项除，所得的余数。

- 需要注意的是，运算结果的正负号由第一个运算项的正负号决定。

	所以，为了得到负数的正确余数值，**可以先使用绝对值函数**。

- 余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。

## 1.3 自增和自减运算符

自增和自减运算符，是一元运算符，只需要一个运算子。

- 它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。

- 运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

- 自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

## 1.4 数值运算符,负数运算符

数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。

数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。

	+true // 1
	+[] // 0
	+{} // NaN

- 上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行NaN也是数值）。具体的类型转换规则


负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。
	
	var x = 1;
	-x // -1
	-(-x) // 1


**数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。**

## 1.5 指数运算符

指数运算符（**）完成指数运算，前一个运算子是底数，后一个运算子是指数。

- **指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算**。

		// 相当于 2 ** (3 ** 2)
		2 ** 3 ** 2
		// 512


## 1.6 赋值运算符

赋值运算符（Assignment Operators）用于给变量赋值。

- 最常见的赋值运算符，当然就是等号（=）。

赋值运算符和算术运算符结合:

	// 等同于 x = x + y
	x += y
	
	// 等同于 x = x - y
	x -= y
	
	// 等同于 x = x * y
	x *= y
	
	// 等同于 x = x / y
	x /= y
	
	// 等同于 x = x % y
	x %= y
	
	// 等同于 x = x ** y
	x **= y

赋值运算符和位运算符结合

	// 等同于 x = x >> y
	x >>= y
	
	// 等同于 x = x << y
	x <<= y
	
	// 等同于 x = x >>> y
	x >>>= y
	
	// 等同于 x = x & y
	x &= y
	
	// 等同于 x = x | y
	x |= y
	
	// 等同于 x = x ^ y
	x ^= y

**这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。**



# 2. 比较运算符

比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。


运算符	|描述	|例子
---|---|---
==	|相等运算符	|x==8 为 false
===	|严格相等运算符（值和类型）	| x===5 为 true；x==="5" 为 false
!=	|不相等运算符	|x!=8 为 true
>	|大于运算符	|x>8 为 false
<	|小于运算符	|x<8 为 true
>=	|大于或等于运算符	|x>=8 为 false
<=	|小于或等于运算符	|x<=8 为 true
!== |严格不相等运算符 |x!=='5' 为true

这八个比较运算符分成两类：

- 相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

## 2.1 非相等运算符：字符串之间的比较

字符串按照字典顺序进行比较。

	'cat' > 'dog' // false
	'cat' > 'catalog' // false

- JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。

		'cat' > 'Cat' // true'

	- 上面代码中，小写的c的 Unicode 码点（99）大于大写的C的 Unicode 码点（67），所以返回true。

- 由于所有字符都有 Unicode 码点，因此汉字也可以比较。


## 2.2 非相等运算符：非字符串的比较

如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

1. 原始类型值

	如果两个运算子都是原始类型(数值,字符串,布尔值)的值，则是先转成数值再比较。

			5 > '4' // true
			// 等同于 5 > Number('4')
			// 即 5 > 4
			
			true > false // true
			// 等同于 Number(true) > Number(false)
			// 即 1 > 0
			
			2 > true // true
			// 等同于 2 > Number(true)
			// 即 2 > 1

	- 这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false。

2. 对象

	如果运算子存在一个是对象，会转为原始类型的值，再进行比较。

		var x = [2];
		x > '11' // true
		// 等同于 [2].valueOf().toString() > '11'
		// 即 '2' > '11'
		
		x.valueOf = function () { return '1' };
		x > '11' // false
		// 等同于 [2].valueOf() > '11'
		// 即 '1' > '11'

	- 两个对象之间的比较也是如此。

			[2] > [1] // true
			// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
			// 即 '2' > '1'
			
			[2] > [11] // true
			// 等同于 [2].valueOf().toString() > [11].valueOf().toString()
			// 即 '2' > '11'
			
			{ x: 2 } >= { x: 1 } // true
			// 等同于 { x: 2 }.valueOf().toString() >= { x: 1 }.valueOf().toString()
			// 即 '[object Object]' >= '[object Object]'


## 2.3 严格相等运算符

JavaScript 提供两种相等运算符：==和===。

- 简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。

### 2.3.1 不同类型的值

如果两个值的类型不同，直接返回false。

	1 === "1" // false
	true === "true" // false

### 2.3.2 同一类的原始类型值

同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。

	1 === 0x1 // true

- 上面代码比较十进制的1与十六进制的1，因为类型和值都相同，返回true。

- 需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。

### 2.3.3 复合类型值

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。

	{} === {} // false
	[] === [] // false
	(function () {} === function () {}) // false

- 上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。

	原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。

如果两个变量引用同一个对象，则它们相等。

	var v1 = {};
	var v2 = v1;
	v1 === v2 // true

- 对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。

		var obj1 = {};
		var obj2 = {};
		
		obj1 > obj2 // false
		obj1 < obj2 // false
		obj1 === obj2 // false

	- 上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回false。



### 2.3.4 undefined和null

undefined和null与自身严格相等。

	undefined === undefined // true
	null === null // true

由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。

	var v1;
	var v2;
	v1 === v2 // true

## 2.4 严格不相等运算符

严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。

	1 !== '1' // true
	// 等同于
	!(1 === '1')

## 2.5 相等运算符

相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。

	1 == 1.0
	// 等同于
	1 === 1.0

比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成四种情况，讨论不同类型的值互相比较的规则。

### 2.5.1 原始类型值

原始类型的值会转换成数值再进行比较。
	
	1 == true // true
	// 等同于 1 === Number(true)
	
	0 == false // true
	// 等同于 0 === Number(false)
	
	2 == true // false
	// 等同于 2 === Number(true)
	
	2 == false // false
	// 等同于 2 === Number(false)
	
	'true' == true // false
	// 等同于 Number('true') === Number(true)
	// 等同于 NaN === 1
	
	'' == 0 // true
	// 等同于 Number('') === 0
	// 等同于 0 === 0
	
	'' == false  // true
	// 等同于 Number('') === Number(false)
	// 等同于 0 === 0
	
	'1' == true  // true
	// 等同于 Number('1') === Number(true)
	// 等同于 1 === 1
	
	'\n  123  \t' == 123 // true
	// 因为字符串转为数字时，省略前置和后置的空格

上面代码将字符串和布尔值都转为数值，然后再进行比较。

### 2.5.2 对象与原始类型值比较

对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。

	// 对象与数值比较时，对象转为数值
	[1] == 1 // true
	// 等同于 Number([1]) == 1
	
	// 对象与字符串比较时，对象转为字符串
	[1] == '1' // true
	// 等同于 String([1]) == '1'
	[1, 2] == '1,2' // true
	// 等同于 String([1, 2]) == '1,2'
	
	// 对象与布尔值比较时，两边都转为数值
	[1] == true // true
	// 等同于 Number([1]) == Number(true)
	[2] == true // false
	// 等同于 Number([2]) == Number(true)

- 数组[1]与数值进行比较，会先转成数值，再进行比较；与字符串进行比较，会先转成字符串，再进行比较；与布尔值进行比较，对象和布尔值都会先转成数值，再进行比较。

### 2.5.3 undefined 和 null

undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。

	false == null // false
	false == undefined // false
	
	0 == null // false
	0 == undefined // false
	
	undefined == null // true

### 2.5.4 相等运算符的缺点

相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

	0 == ''             // true
	0 == '0'            // true
	
	2 == true           // false
	2 == false          // false
	
	false == 'false'    // false
	false == '0'        // true
	
	false == undefined  // false
	false == null       // false
	null == undefined   // true
	
	' \t\r\n ' == 0     // true

- 上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。

## 2.6 不相等运算符

相等运算符有一个对应的“不相等运算符”（!=），它的算法就是先求相等运算符的结果，然后返回相反值。

	1 != '1' // false
	
	// 等同于
	!(1 == '1')


# 3. 布尔运算符

布尔运算符用于将表达式转为布尔值，一共包含四个运算符。

- 取反运算符：`!`
- 且运算符：`&&`
- 或运算符：`||`
- 三元运算符：`?:`

## 3.1 取反运算符(`!`) 

取反运算符是一个感叹号，用于将布尔值变为相反值

对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值取反后都为false。

- undefined
- null
- false
- 0
- NaN
- 空字符串（''）


如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与Boolean函数的作用相同。这是一种常用的类型转换的写法。

	!!x
	// 等同于
	Boolean(x)

## 3.2 且运算符(`&&`)

且运算符（`&&`）往往用于多个表达式的求值。

- 它的运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（**注意是值，不是布尔值**）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。

		't' && '' // ""
		't' && 'f' // "f"
		'' && 'f' // ""

	利用这种运算规则(**短路规则**),可以实现如下的逻辑:

		if (i) {
		  doSomething();
		}
		
		// 等价于
		
		i && doSomething();

且运算符可以多个连用，**这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值**。

	true && 'foo' && '' && 4 && 'foo' && true
	// ''
	
	1 && 2 && 3
	// 3

## 3.3 或运算符(`||`)

或运算符（`||`）也用于多个表达式的求值。

- 它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。

		't' || '' // "t"
		't' || 'f' // "t"
		'' || 'f' // "f"
		'' || '' // ""

	短路规则的应用:

		var x = 1;
		true || (x = 2) // true
		x // 1


或运算符可以多个连用，**这时返回第一个布尔值为true的表达式的值。如果所有表达式都为false，则返回最后一个表达式的值**。

	false || 0 || '' || 4 || 'foo' || true
	// 4
	
	false || 0 || ''
	// ''

或运算符常用于为一个变量设置默认值。

	function saveText(text) {
	  text = text || '';
	  // ...
	}
	
	// 或者写成
	saveText(this.text || '')

- 如果函数调用时，没有提供参数，则该参数默认设置为空字符串

## 3.4 三元条件运算符(`?:`)

三元条件运算符由问号（`?`）和冒号（`:`）组成，分隔三个表达式。

- 它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为true，则返回第二个表达式的值，否则返回第三个表达式的值。


通常来说，三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。

- **但是两者具有一个重大差别，if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值**。

	所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else。

# 4. 二进制位运算符

二进制位运算符用于直接对二进制位进行计算，一共有7个。

名称|符号|解释
---|---|---
二进制或运算符（or）| &#124; |表示若两个二进制位都为0，则结果为0，否则为1。
二进制与运算符（and）|`&`|表示若两个二进制位都为1，则结果为1，否则为0。
二进制否运算符（not）|`~`|表示对一个二进制位取反。
异或运算符（xor）|`^`|表示若两个二进制位不相同，则结果为1，否则为0。
左移运算符（left shift）|`<<`|详见下文解释。
右移运算符（right shift）|`>>`|详见下文解释。
带符号位的右移运算符（zero filled right shift）|`>>>`|详见下文解释。


这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算

- 好处是速度极快
- 缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。


**位运算符只对整数起作用**，**如果一个运算子不是整数**，**会自动转为整数后再执行**。

- 另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数

		i = i | 0;

	- 将i（不管是整数或小数）转为32位整数. **利用这个特性,可以将任意数值转换为32位整数**

			function toInt32(x) {
			  return x | 0;
			}
			toInt32(1.001) // 1
			toInt32(1.999) // 1
			toInt32(1) // 1
			toInt32(-1) // -1
			toInt32(Math.pow(2, 32) + 1) // 1
			toInt32(Math.pow(2, 32) - 1) // -1

		- toInt32可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。

## 4.1 有符号32位整数

所有的按位操作符的操作数都会被转成补码（two's complement）形式的有符号32位整数。

- **补码形式是指一个数的负对应值（negative counterpart）（如 5和-5）为数值的所有比特位反转后，再加1**。

	反转比特位即该数值进行’非‘位运算，也即该数值的反码。


1. 例如下面为整数314的二进制编码：

		00000000000000000000000100111010

2. 下面编码 ~314，即 314 的反码：

		11111111111111111111111011000101

3. 最后，下面编码 -314，即 314 的补码：

		11111111111111111111111011000110


- **补码保证了当一个数是正数时，其最左的比特位是0，当一个数是负数时，其最左的比特位是1。因此，最左边的比特位被称为符号位（sign bit）**。


0 是所有比特数字0组成的整数。

	0 (base 10) = 00000000000000000000000000000000 (base 2)

-1 是所有比特数字1组成的整数。

	-1 (base 10) = 11111111111111111111111111111111 (base 2)

-2147483648（十六进制形式：-0x80000000）是除了最左边为1外，其他比特位都为0的整数。

	-2147483648 (base 10) = 10000000000000000000000000000000 (base 2)

2147483647（十六进制形式：0x7fffffff）是除了最左边为0外，其他比特位都为1的整数。

	2147483647 (base 10) = 01111111111111111111111111111111 (base 2)

- 数字-2147483648 和 2147483647 是32位有符号数字所能表示的最小和最大整数


## 4.1 二进制或运算符(`|`)

二进制或运算符（`|`）逐位比较两个运算子，两个二进制位之中只要有一个为1，就返回1，否则返回0。

	0 | 3 // 3

- 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。

	所以，将一个小数与0进行二进制或运算，等同于对该数去除小数部分，即取整数位。

- 整数不允许超过32位最大值2147483647

		2147483649.4 | 0;
		// -2147483647

## 4.2 二进制与运算符(`&`)

二进制与运算符（`&`）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为0，就返回0，否则返回1。

	0 & 3 // 0

## 4.3 二进制否运算符(`~`)

二进制否运算符（`~`）将每个二进制位都变为相反值（0变为1，1变为0）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。

	~ 3 // -4

- 3的32位整数形式是00000000000000000000000000000011，二进制否运算以后得到11111111111111111111111111111100(负数的补码形式)。

	由于第一位（符号位）是1，所以这个数是一个负数。JavaScript 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值。这个数减去1等于11111111111111111111111111111011，再取一次反得到1000_0000_0000_0000_0000_0000_0000_0100(**注意首位是符号位!**)，结果就是-4

- **简化过程就是: 一个数与自身的取反值相加，等于-1. **

	** 公式 : 数值+该数的取反值 = -1**

- 对一个整数连续两次二进制否运算，得到它自身。

		~~3 // 3

	- 所有的位运算都只对整数有效。二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分。所以，对一个小数连续进行两次二进制否运算，能达到取整效果(**这是最快的取整方式**)。

		~~~3.1 // 3

- 对字符串进行二进制否运算，JavaScript 引擎会先调用Number函数，将字符串转为数值。

	- Number函数将字符串转为数值的规则

- 对于其他类型的值，二进制否运算也是先用Number转为数值，然后再进行处理。


## 4.4 异或运算符

异或运算（`^`）在两个二进制位不同时返回1，相同时返回0。

	0 ^ 3 // 3

- **“异或运算”有一个特殊运用**:

	连续对两个数a和b进行三次异或运算，`a^=b; b^=a; a^=b;`，可以互换它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。

		var a = 10;
		var b = 99;
		
		a ^= b, b ^= a, a ^= b;
		
		a // 99
		b // 10

- 异或运算也可以用来取整。

		12.9 ^ 0 // 12


## 4.5 左移运算符(`<<`)

左移运算符（`<<`）表示将一个数的二进制值向左移动指定的位数，尾部补0，**即乘以2的指定次方。**

正数示例:

	9 (base 10): 00000000000000000000000000001001  (base 2)
	                  --------------------------------
	9 << 2 (base 10): 00000000000000000000000000100100 (base 2) = 36 (base 10)

负数示例:

	-9 (base 10): 1111_1111_1111_1111_1111_1111_1111_0111 (base 2)
	                  --------------------------------
	-9 << 2 (base 10): 1111_1111_1111_1111_1111_1111_1101_1100 (base 2) = 36 (base 10)


- 如果是负数:那么左移之后的值,减去1后取反，再加上负号  就是十进制的值

## 4.6 不带符号位的右移运算符(`>>>`)

该操作符会将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，左侧用0填充。因为符号位变成了 0，所以结果总是非负的。（译注：即便右移 0 个比特，结果也是非负的。）

对于非负数，有符号右移和无符号右移总是返回相同的结果。例如， 9 >>> 2 得到 2 和 9 >> 2 相同：

	9 (base 10): 00000000000000000000000000001001 (base 2)
	                   --------------------------------
	9 >>> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)

但是对于负数却不尽相同。 -9 >>> 2 产生 1073741821 这和 -9 >> 2 不同：
	
	-9 (base 10): 11111111111111111111111111110111 (base 2)
	                    --------------------------------
	-9 >>> 2 (base 10): 00111111111111111111111111111101 (base 2) = 1073741821 (base 10)




## 4.7 带符号位的右移运算符(`>>`)

带符号位的右移运算符（`>>`）表示将第一个操作数向右移动指定的位数。向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变(被称为"符号传播").**即除以2的指定次方（最高位即符号位不参与移动）**

正数示例:

	9 (base 10): 00000000000000000000000000001001 (base 2)
	                  --------------------------------
	9 >> 2 (base 10): 00000000000000000000000000000010 (base 2) = 2 (base 10)


负数示例:

	-9 (base 10): 11111111111111111111111111110111 (base 2)
	                   --------------------------------
	-9 >> 2 (base 10): 11111111111111111111111111111101 (base 2) = -3 (base 10)


## 4.8 开关作用

位运算符可以用作设置对象属性的开关。

假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关。

	var FLAG_A = 1; // 0001
	var FLAG_B = 2; // 0010
	var FLAG_C = 4; // 0100
	var FLAG_D = 8; // 1000


然后，就可以用二进制与运算检验，当前设置是否打开了指定开关。

	var flags = 5; // 二进制的0101
	
	if (flags & FLAG_C) {
	  // ...
	}
	// 0101 & 0100 => 0100 => true

现在假设需要打开A、B、D三个开关，我们可以构造一个掩码变量。

	var mask = FLAG_A | FLAG_B | FLAG_D;
	// 0001 | 0010 | 1000 => 1011


- 二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭。

		flags = flags & mask;

- 异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值。

		flags = flags ^ mask;

- 二进制否运算可以翻转当前设置，即原设置为0，运算后变为1；原设置为1，运算后变为0。

		flags = ~flags;



# 5. 其他运算符,运算顺序



