//Gradle 主要有俩个基本概念  project 和 task
//每个gradle由单个或多个project组成 
//每个project又是由单个或多个task组成

//通常我们称build.gradle 为 构建脚本（尽管严格意义上它是 构建配置脚本）
task sayHello {
	doLast{
		println 'hello gradle!'
	}
}

//-q 可以抑制gradle日志消息 ，近输出任务输出
//gradle -q sH


//doLast的快捷键 在gradle5.0 中会被遗弃，取而代之的是 doLast  doFirst
task sayHi <<{
	println 'hi gradle!'
}


task count<<{
	4.times{
		println "$it"
	}
}



//任务依赖
task func1(dependsOn:sayHi){
	doLast{
		println 'func1'
	}
}

//任务依赖的任务  被依赖任务的定义 可以迟于依赖任务
//lazyDependsOn
task funcx(dependsOn:'funcy'){
	doLast{
		println 'funcx'
	}
}

task funcy {
	doLast{
		println 'funcy'
	}
}



//groovy 可以动态创建task
4.times{ number->
	task "task$number"{
		doLast
		{
			println "i am task number $number"		
		}
	}
}


//创建任务之后，可以在运行时 动态的添加依赖关系
//例如我上面创建了 4个task task0,task1,task2,task3
task0.dependsOn(task2,task1,task3)


//可以通过API访问task，用来添加action
task func2{
	doLast{
			println 'normal '
	}
}

func2.doFirst{
	println 'before normal'
}

func2.doLast{
	println 'after normal'
}

func2{
	doLast{
		println 'after after normal'
	}
}



//可以通过ext.xxxx  来替task设置额外属性
task func3{
	ext.nameProperty = 'jack'
}

task func4{
	doLast{
		println "func3 name = $func3.nameProperty"
	}
}



//设置默认task
// defaultTasks 'clean','run'
// task clean{
// 	doLast{
// 			println "clean $version"
// 	}
// }

task run<<{
	println "run $version"
}

//运行 gradle -q 时， 默认会执行 clean  和run

//gradle 具有配置阶段 和 执行阶段
//在配置阶段之后，gradle 已经知道所有需要执行的任务
//gradle 提供了一个hook 方法 来利用这些信息
gradle.taskGraph.whenReady{
	taskGraph-> if (taskGraph.hasTask(run)) {
		version = '1.0.0.run'
	}else{
		version = '1.0.0.clean'
	}
}

//在build.gradle 中 所有未定义的方法/属性 都会委派给 Project 对象去使用
// println "name = $name"
// println "project.name = ${project.name}"
// println "path = $path"
// println "description = $description"
// println "buildDir = ${buildDir.path}"
// println "projectDir = ${projectDir.path}"

//this 在嵌套闭包的情况下 ，会返回外部类
//owner 在嵌套闭包的情况下，会返回外部闭包
task func6{
	doLast{
		println "name = $name"
		println "this.name = ${this.name}"
		println "owner.name = ${owner.name}"
	}
}



// Project 提供了一些属性
/*
	Name 		Type  		Default Value
	project  	Project   	The project instance
	name 		String		the name of the project directory	
	path		String		the absolute path of the project
	description String		a description for the project
	projectDir  File 		the directory containing the build script
	buildDir    File 		projectDir/build
	group		Object 		
	version		Object
	ant			AntBuilder  an AntBuilder instance
*/



//脚本api ，当gradle 执行script 时，会将脚本编译成一个实现了Script的 类，这以为 script中的方法 属性 都可以用！



//声明变量
//local variables , extra properties
//局部变量 用def 声明，且只能在被定义的地方可见(Groovy特征)
def dest = 'dest'
task copy(type:Copy){
	from "hello.txt"
		//传的是路径
	into dest
}




//额外的属性  可以用 ext 属性添加
//project  task source-set 都可以添加
//ext可以一次性添加 多个属性
//引用的时候 直接使用这个额外属性的名称即可
project.ext{
	emailDesc = 'this is test text'
	emailAddress = 'mychocolateisus@gmail.com'
}

task func7{
	doLast{
		println emailDesc
	}
}


//TODO
//在任意对象中配置 属性....貌似不行！！！！！！！！！
// task func8 {
// 	doLast{
// 		def file = configure(new File("hello.txt")){
// 			startT = 'startT'
// 			endT = 'endT'
// 		}
// 		println file.startT
// 	}
// }

// apply plugin: 'java'

// task configure { 
//     doLast { 
//         def pos = configure（new FieldPosition（10））{ 
//             beginIndex = 1 
//             endIndex = 5 
//         } 
//         println pos.beginIndex 
//         println pos.endIndex 
//     } 
// }




//TODO  貌似也不行。。
//可以通过使用单独的一个build.gradle 文件 来充当配置
//例如  other.gradle
// task func9{
// 	doLast{
// 		def cl = new File('user')
// 		apply from:'other.gradle',to:cl
// 		println cl.beginIndex
// 		println cl.endIndex
// 	}
// }


//根据groovy的语法 ，一个property 会自动生成 get/set方法



//方法调用的时候 可以选择 加括号 或者不加括号
//需要注意的是 当方法没有参数时..可能会被当做 属性来处理
def method1(){
	println 'hello'
}
method1()

def method2(a){
	println "method2 a=$a"
}
method2 1
method2(1)



//apply 方法 实际需要的是 一个 键值对
//当方法的最后一个参数是 闭包时， 可以把闭包放到 方法调用之后 
def method3(Closure cl){
	cl()
}
// 以下三种调用方法的方式 是一样的效果
method3(){
	println 'method3 1'
}
method3({println 'method3 2'})
method3 {
	println 'method3 3'
}
method3 {
	println "delegate = "+delegate
	println "project.allprojects = "+ project.allprojects
}

apply plugin:'java'

// dependencies {
//     assert delegate == project.dependencies
//     println 'dependencies is running'
//     testCompile('junit:junit:4.12')
//     delegate.testCompile('junit:junit:4.12')
// }

method3 {
	println "owner = $owner"
	println "delegate = $delegate"
	println "this = $this"
	assert delegate != project
	assert this !=project
	assert owner !=project
	assert owner == delegate
}

def toolingApiVersion = gradle.gradleVersion
println 'toolingApiVersion = '+toolingApiVersion

repositories {
    maven { url 'https://repo.gradle.org/gradle/libs-releases' }
}

dependencies {
    compile "org.gradle:gradle-tooling-api:${toolingApiVersion}"
    // The tooling API need an SLF4J implementation available at runtime, replace this with any other implementation
    runtime 'org.slf4j:slf4j-simple:1.7.10'
}


//gradle 自动帮开发者导入了 一大堆的库
//gradle  可以通过 tooling api 来标记不同的任务结果
/*
标签： no label or EXECUTED     说明：任务已经执行完成     
情况： 当任务有动作且gradle确定task 是作为构建的一部分

标签：UP-TO-DATE    说明：任务输出没有改变
情况： 1.当一个任务有输入有输出并且这些没有改变
	   2.当一个任务有action，并且task输出没有改变
	   3.当一个任务没有action，但是又 dpendencies 。并且这些dependencies 已经是UP-TO-DATE,SKIPPED or from CACHE
	   4.当一个任务没有acton，也没有dependencies


标签:FROM-CACHE 说明：任务的输出是从之前的执行结果中获得
情况:当任务存有构建输出缓存

标签：SKIPPED 说明：任务action'被跳过
情况:1.当一个任务被明确的从 命令行中排除在外
	 2.当一个任务 返回了 false

标签：NO-SOURCE 说明：任务无需执行其action
情况: 任务有输入有输出，但是没有source ，例如：source files are .java files for JavaCompile
*/




//定义任务
//可以使用字符串作为任务名称
/*
 task myTask
 task myTask { configure closure }
 task myTask(type: SomeType)
 task myTask(type: SomeType) { configure closure }
*/

task ('task4'){
	doLast{
		println 'hello task4'
	}
}

task (task5,type:Copy){
	from 'hello.txt'
	into 'copy'
}

task task6{
	doLast{
		println 'hello task6'
	}
}

//创建任务的另一种方式
tasks.create(name:'task7'){
	group 'test'
	description 'test tasks.create'
	doLast{
		println 'task7'
	}
}

tasks.create(name:'task8',type:Copy){
	group 'test'
	from 'hello.txt'
	into 'copy'
}




//可以将任务作为属性来使用
println task8.name
println project.task8.name


//通过tasks collection  来访问task
println tasks.task8.name
println tasks['task8'].name

//可以通过tasks.getByPath()方法 来获取  使用任务名称 ，相对路径 或者绝对路径调用该方法

project(':script'){
	task task9
}

println tasks.getByPath('task9').path
println tasks.getByPath(':script:task9').path

//配置任务  
//方式1
Copy copy1 = task(task10,type:Copy)
copy1.from '/'
copy1.into 'task10'
copy1.include('**.txt')

//方式2
task task11(type:Copy)

task11{
	from '/'
	into 'task11'
	include '**.txt'
}

//方式3
task (task12,type:Copy){
	from '/'
	into 'task12'
	include '**.gradle'
}



//为task添加dependencies
//添加 来自其他project的依赖
project(':script'){
	task task13(dependsOn:':script2:task14')<<{
		println 'scrip task13 is runned'
	}
}

project(':script2'){
	task task14{
		doLast{
			println 'script2 task14 is runned'
		}
	}
}

//同一project中 
//注释掉 下面也可以用
// task6.dependsOn task7 


//可以使用一个闭包 来返回闭包
task6.dependsOn {
	tasks.findAll{
		it.name.startsWith('task7')
	}
}




//Ordering task
//mustRunAfter shouldRunAfter
task task15{
	doLast{
		println 'task15'
	}
}
task task16{
	doLast{
		println 'task16'
	}
}
//只有 俩个任务同时调用时，规则才会生效
//运行时 使用--continue , 可以在任务失败之后 继续执行
// task15.mustRunAfter task16

task15.shouldRunAfter task16

task taskA<<{
	println 'taskA'
}

task taskB<<{
	println 'taskB'
}

task taskC<<{
	println 'taskC'
} 
//如果添加了 依赖关系， 那么 shouldRunAfter 不起作用,另外不能再添加mustRunAfter
taskA.dependsOn(taskB)
taskB.dependsOn(taskC)
taskC.shouldRunAfter taskA


//通过group 设置分组
//通过 description 设置描述
taskC.group = 'test'
taskC.description = '-------------'


//通过overwrite  覆盖任务
//如果不添加overwrite ，那么会抛出一个异常 表示任务已经存在

task task17<<{
	println 'task17'
}
task task17(overwrite:true)<<{
	println "task17 overwrited"
}



//通过onlyIf 来跳过任务
task task18<<{
	println 'task18'
}
task18.onlyIf {
	!project.hasProperty('skiptask18')
}
//通过-P 设置属性
//运行gradle -q task18 -Pskiptask18



//通过抛出StopExecutionException
task task19<<{
	println 'task19'
}
task19.doFirst{
	if (true) {
		throw new StopExecutionException()
	}
}
task task20(dependsOn:task19) <<{
	println 'task20 not affected'
}


//task 拥有一个 enabled  的属性
task task21<<{
	println 'task21'
}
task21.enabled = false


//UP-TO-DATE CHECK
//Task.getInputs()   TaskInputs
//Task.getOutputs()   TaskOutputs
//Task.getDestroyables()  TaskDestroyables


// task processTemplatesAdHoc {
//     inputs.property("engine", TemplateEngineType.FREEMARKER)
//     inputs.files(fileTree("src/templates"))
//     inputs.property("templateData.name", "docs")
//     inputs.property("templateData.variables", [year: 2013])
//     outputs.dir("$buildDir/genOutput2")

//     doLast {
//         // Process the templates here
//     }
// }

//生命周期任务
//许多 gradle 插件 定义了自己的声明周期任务，以方便执行特定的操作




//20 -----------------------------------------------------------------------------------------
//locating file  Project.file()
//使用相对路径
File file1 = file('hello.txt')
println "file1 = ${file1.getText()}"
//使用绝对路径
File file2 = file(file1.absolutePath)
println "file2 = ${file2.getText()}"
//使用具有相对路径的File对象
File file3 = file(new File('hello.txt'))
println "file3 = ${file3.getText()}"


//file 还可以理解 URL  例如 file:/some/path.xml




//FileCollection
//通过files()获得
//可以将 集合，迭代 映射 和数组传给此方法。这些将会被展开并转换成实例
FileCollection collection1 = files('hello.txt',new File('other.gradle'))
FileCollection collection2 = files('hello.txt')
collection1.each{
	println "file name =${it.name}"
}
//将FileCollection转换成　各种类型
Set set1 = collection1.files
Set set2 = collection1 as Set
List list1 = collection1 as List
String path1 = collection1.asPath
//以下俩个方法当FileCollection只存在一个 File时可以使用
File file4 = collection2.singleFile
File file5 = collection2 as File



//添加和减去 FileCollection
def union1 = collection1 + files('build.gradle')
union1.each{
	println "union1 file name = ${it.name}"
}
def different1 = collection1 - files('hello.txt')
different1.each{
	println "different1 file name = ${it.name}"
}




task list1<<{
	File srcDir

	FileCollection collection = files {srcDir.listFiles()}

	srcDir = file('src')
	println "Contents of $srcDir.name"
	collection.collect {
		relativePath(it)
	}.sort().each {
		println it
	}


}




//文件树是按照层次排列文件的集合
//由FileTree 表示，其扩展了FileCollection
//Project.fileTree(Map) 

FileTree tree1 = fileTree(dir:'src')
//添加 包含和不包含的规则
// tree1.include '*.txt'
tree1.exclude '*.gradle'
tree1.each{
	println "FileTree $it.name"
}



//创建方式2
tree1 = fileTree('src').include('*.gradle')

//创建方式3
tree1 = fileTree('src'){
	include '*.txt'
}

//创建方式4 通过map创建

tree1 = fileTree(dir:'src',include:'*.txt')
tree1 = fileTree(dir:'src',include:['*.txt','*.gradle'])
tree1 = fileTree(dir:'src',include:'*',exclude:'')

//筛选FileTree
FileTree filtered1 = tree1.matching{
	include '*.txt'
}

//遍历FileTree
filtered1.each{
	println "file name = $it.name"
}


// Add trees together
FileTree sum = filtered1 + fileTree(dir: 'src',include:'*.txt')

// Visit the elements of the tree
sum.visit {element ->
    println "$element.relativePath => $element.file"
}



//可以将 zip or tar 作为文件树 
//以下俩个方法会返回FileTree
//Project.zipTree(Object)
//Project.tarTree(Object)

// FileTree someTar1 = tarTree(resources.gzip('xxx.ext'))
// someTar1.each{
// 	println it.name
// }




//指定一组输入文件
// task compile1(type:JavaCompile){
// 	source = file('src')
// }
//source= file('src') 接受一个file对象
//source = 'src' 接收路径
//source = ['src','dest']  可以使用集合来指定多个源目录
//source = fileTree(dir:'src').matching{ include '*.gradle'} 可以接收一个fileTree
//source = { file('src').listFiles().findAll{ it.name.endsWith('.zip')}.collect{zipTree(it)}   }
 



 //Copying file
 //复制文件时，可以过滤内容 
 //需要提供 from   into   

 task copy2(type:Copy){
 	from 'src'
 	into 'dest'
 }

 //from 可以接收一个files()方法作为参数
 //当参数被解析时，如果是目录，则该目录下的所有内容将被递归复制到目标目录下（注意：不是目录本身）
 //当参数被解析后，不存在，则会忽略
 //当参数是task时，即取 task 的输出结果，并且该task会被添加为Copy task的依赖

 task copy3(type:Copy){
 	//目录
 	from 'src'
 	//单个文件
 	from 'src/b.txt'
 	//task的输出
 	// from copyTask
 	//明确指定任务的输出
 	// from copyTaskWithPatterns.outputs
 	//指定zip file
 	// from zipTree('src/xx.zip')
 	// into { getDestDir()}
 }




 //在copy时，对输入文件进行筛选
 task copy4(type:Copy){
 	from 'src'
 	into 'copy4'
 	include '*.txt'
 	//传入闭包的话 会给闭包一个 FileTree 参数
 	exclude {
 		it.file.name.startsWith 'a'
 	}
 }



 //除了使用 定义一个task 指定Copy 类型外，  Project 也提供了copy 方法
 task copy5<<{
 	copy{
 		from 'src'
 		into 'copy5'
 	}
 }

 task copy6{
 	inputs.file copy2
 	outputs.dir 'copy6'
 	doLast{
 		copy{
 			from copy2
 			into 'copy6'
 		}
 	}
 }

//重命名 file
 task rename1(type:Copy){
 	from 'hello.txt'
 	into '/'
 	rename{
 		it.replace('hello','hi')
 	}
 }

//嵌套输出 
task copy7(type:Copy){
	into 'copy7'
	exclude '*.txt'
	from('src'){
		include '*'
	}

	into('copy7') {
		exclude '*.java'
		from 'src'
	}
}

//Sync 是扩展自Copy
//与copy的区别就是， Sync 会将文件先全部复制到 目标目录下，然后再将不需要的删除
task copy8(type:Sync){
	from 'src'
	into 'copy8'
}



//创建 zip
//默认 应该是生成在buiild下
//命名规则应该是 projectName-version.type 
//version 可以在task中指定。。 貌似在 全局设置version 没用！
//baseName 可以替换掉 projectName 
//baseName - appendix - version - classifier .type
task zip1(type:Zip){
	version = 1.5
	baseName = 'xixixixi'
	appendix = 'appendix'
	classifier = 'classifier'
	from 'src'
}




// 22--------------------------------------------------------------
//build LifeCycle
// Gradle 构建有三个不同阶段  
// 1.initialization  gradle 决定哪些项目将参与构建，并且为每个project创建一个实例
// 2.Configuration  作为构建一部分的构建脚本会被执行
// 3.Execution  gradle 确定了一系列任务（在2阶段 被创建 和 配置的），然后gradle按顺序执行每个任务



//Settings file
//除了构建脚本 build.gradle之外，gradle 还提供了一个 settings.gradle 
//settings.gradle 在初始化阶段执行。另外 多项目构建 必须有settings.gradle 

println "this is executed during the Configuration phase"

task configured{
	println "this is executed during the Configuration phase"
	doLast{
		println "this is executed during the Execution phase"
	}

	doFirst{
		println "this is executed during the Execution phase"
	}

}

//属性访问 和 方法调用 被project 代理
//同理 属性访问 和 方法调用 在settings.gradle 中 被 settings 代理



//通过以下设置 可以在 task被添加到project时立刻接收到通知
//这可以用来设置一些默认值或行为（task在Build file中可用之前）
tasks.whenTaskAdded{
	it.ext.srcDir = 'src'
}

task task22<<{
	println "task22 srcDir =$srcDir "
}


//task 执行图绘制完毕
//应该是配置结束
gradle.taskGraph.whenReady{
	println "taskGraph.whenReady =  $it"
}