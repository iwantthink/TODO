# HTTP学习

[HTTP必知必会的那些](https://mp.weixin.qq.com/s/Fazx13maQfPJItfkOqk9FQ)

[HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html)


[理解OAuth 2.0  阮一峰](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)

# 1. 简介

1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，**直到现在还是最流行的版本**。

## 1.1 持久连接

1.1 版的最大变化，就是引入了持久连接（`persistent connection`），即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。

目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。



# 2. HTTP报文

HTTP报文可以分为请求报文和响应报文，格式大同小异。主要分为三个部分：

1. 起始行

2. 首部

3. 主体

## 2.1 请求报文格式

格式:

	<method> <request-url> <version>
	<headers>
	
	<entity-body>


实例:

	GET http://s1.mini.wpscdn.cn/config/wps/tray/boot.json?_t=1545127200 HTTP/1.1
	User-Agent: Mozilla/5.0
	Host: s1.mini.wpscdn.cn
	Pragma: no-cache

	POST https://servicecut.meizu.com/interface/locate HTTP/1.1
	X-SDK-VERSION: 2.2.1
	X-SN: 91QEBPF5SF29
	X-IMEI: 862937039710025
	X-MAC: 
	User-Agent: Dalvik/2.1.0 (Linux; U; Android 5.1; m3 note Build/LMY47I)
	Host: servicecut.meizu.com
	Connection: Keep-Alive
	Accept-Encoding: gzip
	Content-Type: application/x-www-form-urlencoded
	Content-Length: 48
	
	name=uxip.meizu.com&sim_card_sp=wifi&version=2.0


## 2.2 响应报文格式

格式:

	<version> <status> <reason-phrase>
	<headers>
	
	<entity-body>

- 注意首部与实体之间存在空行

实例:

	HTTP/1.1 200 OK
	Connection: close
	Content-Length: 0


## 2.3 标签含义

- `<method>` 指请求方法，常用的主要是Get、 Post、Head

- `<version>` 指协议版本，现在通常都是Http/1.1了

- `<request-url>` 请求地址

- `<headers>` 请求头

- `<status>` 指响应状态码， 我们熟悉的200、404等等

- `<reason-phrase>` 原因短语，200 OK 、404 Not Found 这种后面的描述就是原因短语，通常不必太关注。


### 2.3.1 method标签

请求方法常用的有`GET` 和`POST`俩种,俩者的区别是:

1. **传输形式有区别**:

	**`GET`方法发起的请求,会将请求参数拼接在`<request-url>`尾部,格式是`url?param=xxx&param2=xxx&[.....]`**

	这种传输形式使得参数都暴露在地址栏中,并且`url`是`ASCII`编码的,如果参数中出现`Unicode`编码的字符,例如汉字等, 都会经过编码后再传输 

	另外`HTTP`协议本身并没有对url长度做限制,但是一些浏览器和服务器可能会有限制,所以通过`GET`方法发起的请求中参数不能够太长

	**`POST`方法发起的请求是将参数放在请求体中**,不会存在参数过长的问题

2. **方法本身的语意有区别:**

	GET方法通常是指从服务器获取某个URL资源，其行为可以看作是一个读操作，对同一个URL进行多次GET并不会对服务器产生什么影响。

	而POST方法通常是对某个URL进行添加、修改，例如一个表单提交，通常会往服务器插入一条记录。多次POST请求可能导致服务器的数据库中添加了多条记录。所以从语义上来讲，两者也是不能混为一谈的


### 2.3.2 status标签

常见的状态码主要有  

- 200 OK  请求成功，实体包含请求的资源  

- 301 Moved Permanent 请求的URL被移除了，通常会在Location首部中包含新的URL用于重定向。  

- 304 Not Modified    条件请求进行再验证，资源未改变。  

- 404 Not Found       资源不存在  

- 206 Partial Content 成功执行一个部分请求。这个在用于断点续传时会涉及到。

### 2.3.3 header标签

在请求报文和响应报文中都可以携带一些信息，通过与其他部分配合，能够实现各种强大的功能。这些信息位于起始行之下与请求实体之间，以键值对的形式，称之为首部。

每条首部以回车换行符结尾，最后一个首部额外多一个换行，与实体分隔开。

**比较重要的首部标签:**

	Date  
	Cache-Control  
	Last-Modified  
	Etag  
	Expires  
	If-Modified-Since   
	If-None-Match  
	If-Unmodified-Since  
	If-Range  
	If-Match

## 2.4 主体

请求发送的资源,或者是说返回的资源

# 3. HTTP缓存

发起一个HTTP请求后，服务器返回所请求的资源，这时客户端可以将该资源的副本存储在本地，这样当再次对该url资源发起请求时，客户端能快速的从本地存储设备中获取到该url资源，这就是所谓的缓存。

- 缓存既可以节约不必要的网络带宽，又能迅速对http请求做出响应。


## 3.1 HTTP缓存中的概念

1. 新鲜度检测

2. 再验证

3. 再验证命中


网络请求中,有些url所对应的资源并不是一成不变的，服务器中该url的资源可能在一定时间之后会被修改,这时本地缓存中的资源将与服务器一侧的资源有差异。

既然在一定时间之后可能资源会改变，那么在某个时间之前我们可以认为这个资源没有改变，从而放心大胆的使用缓存资源，当请求时间超过来该时间，则认为这个缓存资源可能不再与服务器端一致了。**所以当发起一个请求时，需要先对缓存的资源进行判断，看看究竟我们是否可以直接使用该缓存资源，这个就叫做新鲜度检测**。即每个资源就像一个食品一样，拥有一个过期时间，吃之前需要先看看有没有过期。

如果发现该缓存资源已经超过了一定的时间，**那么再次发起请求时不会直接将缓存资源返回，而是先去服务器查看该资源是否已经改变，这个就叫做再验证**。

如果服务器发现对应的url资源并没有发生变化，则会**返回`304 Not Modified`，并且不再返回对应的实体,这称之为再验证命中**。相反如果再验证未命中，则返回`200 OK`，并将改变后的url资源返回，此时缓存可以更新以待之后请求。


## 3.2 缓存具体实现方式

1. **新鲜度检测**  

	需要通过检测资源是否超过一定的时间，来判断缓存资源是否新鲜可用。那么这个一定的时间怎么决定呢？

	其实是由服务器通过在响应报文中增加`Cache-Control:max-age`，或是`Expire`这两个首部来实现的。

	值得注意的是`Cache-Control`是`http1.1`的协议规范，通常是接相对的时间，即多少秒以后，需要结合`last-modified`这个首部计算出绝对时间。而`Expire`是`http1.0`的规范，后面接一个绝对时间。

2. 再验证  

	如果通过新鲜度检测发现需要请求服务器进行再验证，那么至少需要告诉服务器，已经缓存了一个什么样的资源了，然后服务器来判断这个缓存资源到底是不是与当前的资源一致。逻辑是这样没错。那怎么告诉服务器当前已经有一个备用的缓存资源了呢？

	可以采用一种称之为**条件请求的方式**实现再验证。

	- **Http定义了5个首部用于条件请求**:  
	
			If-Modified-Since   
			If-None-Match  
			If-Unmodified-Since  
			If-Range  
			If-Match

	`If-Modified-Since` 可以结合`Last-Modified`这个服务器返回的响应首部使用，当发起条件请求时，将`Last-Modified`首部的值作为`If-Modified-Since`首部的值传递到服务器，意思是查询服务器的资源自从上一次缓存之后是否有修改。

	`If-None-Match` 需要结合另一个`Etag`的服务器返回的响应首部使用。`Etag`首部实际上可以认为是服务器对文档资源定义的一个版本号。有时候一个文档被修改了，可能所做的修改极为微小，并不需要所有的缓存都重新下载数据。或者说某一个文档的修改周期极为频繁，以至于以秒为时间粒度的判断已经无法满足需求。这个时候可能就需要`Etag`这个首部来表明这个文档的版号了。发起条件请求时可将缓存时保存下来的`Etag`的值作为`If-None-Match`首部的值发送至服务器，如果服务器的资源的`Etag`与当前条件请求的`Etag`一致，表明这次再验证命中。  

## 3.3 OkHttp的缓存机制介绍



# 4. Https

> 简单的说 Https = Http + 加密 + 认证 + 完整性保护


传统的Http协议是一种应用层的传输协议,Http直接与TCP协议通信,其本身存在一些缺陷

1. Http协议使用明文传输，容易遭到窃听。

2. Http对于通信双方都没有进行身份验证，通信的双方无法确认对方是否是伪装的客户端或者服务端。

3. Http对于传输内容的完整性没有确认的办法，往往容易在传输过程中被劫持篡改。


因此，在一些需要保证安全性的场景下，比如涉及到银行账户的请求时，Http无法抵御这些攻击。  
**而`Https`则可以通过增加的SSL\TLS，支持对于通信内容的加密，以及对通信双方的身份进行验证。**


## 4.1 Https加密


近代密码学中加密的方式主要有两类：

1. 对称秘钥加密

	对称秘钥加密是指加密与解密过程使用同一把秘钥。这种方式的优点是处理速度快，但是如何安全的从一方将秘钥传递到通信的另一方是一个问题。

2. 非对称秘钥加密

	非对称秘钥加密是指加密与解密使用两把不同的秘钥。这两把秘钥，一把叫公开秘钥，可以随意对外公开。一把叫私有秘钥，只用于本身持有。得到公开秘钥的客户端可以使用公开秘钥对传输内容进行加密，而只有私有秘钥持有者本身可以对公开秘钥加密的内容进行解密。这种方式克服了秘钥交换的问题，但是相对于对称秘钥加密的方式，处理速度较慢。


**SSL\TLS的加密方式**则是结合了两种加密方式的优点。

1. 首先采用非对称秘钥加密，将一个对称秘钥使用公开秘钥加密后传输到对方。

2. 对方使用私有秘钥解密，得到传输的对称秘钥。之后双方再使用对称秘钥进行通信

	这样即解决了对称秘钥加密的秘钥传输问题，又利用了对称秘钥的高效率来进行通信内容的加密与解密。


## 4.2 Https认证


SSL\TLS采用的混合加密的方式还是存在一个问题，即怎么样确保用于加密的公开秘钥确实是所期望的服务器所分发的呢？也许在收到公开秘钥时，这个公开秘钥已经被别人篡改了。因此，我们还需要对这个秘钥进行认证的能力，以确保我们通信的对方是我们所期望的对象。

- 目前的做法是使用由数字证书认证机构颁发的公开秘钥证书。服务器的运营人员可以向认证机构提出公开秘钥申请。认证机构在审核之后，会将公开秘钥与共钥证书绑定。服务器就可以将这个共钥证书下发给客户端，客户端在收到证书后，使用认证机构的公开秘钥进行验证。一旦验证成功，即可知道这个秘钥是可以信任的秘钥。

## 4.3 流程总结

Https的通信流程：

1. Client发起请求

2. Server端响应请求，并在之后将证书发送至Client

3. Client使用认证机构的共钥认证证书，并从证书中取出Server端共钥。

4. Client使用共钥加密一个随机秘钥，并传到Server

5. Server使用私钥解密出随机秘钥

6. 通信双方使用随机秘钥作为对称秘钥进行加密解密。


# 4. OAuth

`OAuth`是一个用于**授权第三方获取相应资源的协议**。与以往的授权方式不同的是，`OAuth`的授权能避免用户暴露自己的用户密码给第三方，从而更加的安全。

`OAuth`协议通过设置一个授权层，以区分用户和第三方应用。用户本身可以通过用户密码登陆服务提供商，获取到账户所有的资源。而第三方应用只能通过向用户请求授权，获取到一个`Access Token`，用以登陆授权层，从而在指定时间内获取到用户授权访问的部分资源。



