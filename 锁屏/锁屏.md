FrameNew是个加载的框架
FrameCoreNew是锁屏逻辑部分
FrameNew只负责创建独立进程服务和加载FrameCoreNew
KeepService类onCreate函数android.os.Debug.waitForDebugger();这段代码是为了能单步调试FrameCoreNew的
FrameInstance类IsDEBUG是判断是否使用本地FrameCoreNew版本
你现在给的apk，使用的是网络上的FrameCoreNew版本
apk是单步调式的版本，KeepService类onCreate函数android.os.Debug.waitForDebugger();这段代码是为了能单步调试FrameCoreNew的，这个要删除
不然不会有广告的

# 1. FrameNew
加载的框架，负责创建独立进程服务和加载FrameCoreNew

KeepService类onCreate函数android.os.Debug.waitForDebugger();这段代码是为了能单步调试FrameCoreNew的

FrameInstance类IsDEBUG是判断是否使用本地FrameCoreNew版本

## 1.1 registerApp

	StartSDK.getInstance().registerApp()
    public void registerApp(Context c, String  appKey, String imei) {
    	int nJobId = start(c);
		Until.WriteAppKey(c, appKey, imei);
		KeepService.startKeepService(c, nJobId);
	}

## 1.2 start(Context ctx)

判断SDK是否>=21(5.0),创建一个定时JobInfo(10秒)去执行任务，会返回一个大于0的值(低版本上如果成功会返回定义好的jobID，高版本返回1 表示成功)

`start()`方法执行逻辑： 开启KeepService

- type: 固定字符串`job`
- id: JobInfo的ID

[JobScheduler API](https://developer.android.com/reference/android/app/job/JobScheduler.html)
[JobScheduler Doc](https://developer.android.com/topic/performance/background-optimization.html#connectivity-action)
[JobScheduler 介绍](https://www.jianshu.com/p/9fb882cae239)
[JobScheduler 介绍2](https://www.jianshu.com/p/be0f3cc505ec)

## 1.3 Scheduler-JobService

获取imei，注册广播

1. registerComponent 监听一系列action的广播

		android.intent.action.SCREEN_ON //屏幕开启
		android.intent.action.SCREEN_OFF //屏幕关闭
		android.intent.action.USER_PRESENT //解锁
		android.net.conn.CONNECTIVITY_CHANGE //网络状态发生变化
		android.intent.action.DOWNLOAD_COMPLETE //下载完成
		android.intent.action.DOWNLOAD_NOTIFICATION_CLICKED //用户点击了下载任务的通知栏
		android.intent.action.CLOSE_SYSTEM_DIALOGS//系统提示框dismiss时

	广播逻辑,`onReceive`中的逻辑：

	- SCREEN_OFF:

			FrameInstance.getInstance().displayPushActivityEx()

	- SCREEN_ON:DO NOTHING

	- DOWNLOAD_COMPLETE:

			long downloadApkId = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, 0);
	        FrameInstance.getInstance().DownloadFinish(downloadApkId);

	- ACTION_NOTIFICATION_CLICKED:

	 		long downloadApkId = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, 0);
	        FrameInstance.getInstance().DownloadClicked(downloadApkId);

2. registerLockScreen

	注册广播，action = pkg+`'service.RECEIVER'`

	广播逻辑：根据intent中带的参数 决定具体的执行逻辑

	- lockscreen:启动MsgManager Activity
	- browser:启动 BrowserActivity Activity
	- adver：
	
			Boolean bIsTest = bundle.getBoolean("IsTest");
	        FrameInstance.getInstance().StartAdver(bIsTest);

	- stop：关闭JobScheduler,关闭子线程(),关闭当前服务，杀死当前进程

3. registerInstall

	注册app安装和卸载的广播

	广播逻辑：

       if(bIsRun){
          FrameInstance.getInstance().onInstallReceive(context, intent);
        }

4. 调用FrameInstance

		FrameInstance.getInstance(this).InitLogic();

5. 执行TASK，runnable 

	逻辑：每三十秒获取一次imei.

## 1.4 FrameInstance

### 1.4.1 constuction

定义了一个Handler

### 1.4.2 InitLogic

根据是否是DEBUG模式

- true:

		loadFrameCoreDebug(Context c)

- false：

### 1.4.3 loadFrameCoreDebug（Cotnext c）



# 2. FrameCoreNew